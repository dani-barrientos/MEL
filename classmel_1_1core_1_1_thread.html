<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: mel::core::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmel_1_1core_1_1_thread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmel_1_1core_1_1_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mel::core::Thread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Platform-independent thread implementation. <br  />
  
 <a href="classmel_1_1core_1_1_thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_8h_source.html">Thread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1311e02532c75f98cd21db2e82a59beb"><td class="memItemLeft" align="right" valign="top"><a id="a1311e02532c75f98cd21db2e82a59beb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>YieldPolicy</b> { <b>YP_ANY_THREAD_ANY_PROCESSOR</b> =0
, <b>YP_ANY_THREAD_SAME_PROCESSOR</b>
 }</td></tr>
<tr class="separator:a1311e02532c75f98cd21db2e82a59beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8dd5fa37265e74107c20acac3d6e33f5"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a8dd5fa37265e74107c20acac3d6e33f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a8dd5fa37265e74107c20acac3d6e33f5">Thread</a> (F &amp;&amp;f)</td></tr>
<tr class="separator:a8dd5fa37265e74107c20acac3d6e33f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6e151220c5b492718e24795844f18c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a6f6e151220c5b492718e24795844f18c">~Thread</a> ()</td></tr>
<tr class="separator:a6f6e151220c5b492718e24795844f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac5fe6b306866f66da2d65ad79455ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a3ac5fe6b306866f66da2d65ad79455ec">setPriority</a> (<a class="el" href="namespacemel_1_1core.html#a09ec81fbf60f4c62e32529b58234f82f">ThreadPriority</a> tp)</td></tr>
<tr class="separator:a3ac5fe6b306866f66da2d65ad79455ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5839512d902b624b1027d22bc7730fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemel_1_1core.html#a09ec81fbf60f4c62e32529b58234f82f">ThreadPriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ac5839512d902b624b1027d22bc7730fc">getPriority</a> () const</td></tr>
<tr class="separator:ac5839512d902b624b1027d22bc7730fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a9ffeece50097f4eafa9f161988bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a32a9ffeece50097f4eafa9f161988bef">join</a> (unsigned int millis=0xFFFFFFFF)</td></tr>
<tr class="separator:a32a9ffeece50097f4eafa9f161988bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aef994ca33536894e6b15c8adc8c3a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a48aef994ca33536894e6b15c8adc8c3a">getResult</a> () const</td></tr>
<tr class="separator:a48aef994ca33536894e6b15c8adc8c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a64a50ffea1498404e941eedfed0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ae44a64a50ffea1498404e941eedfed0c">isRunning</a> () const</td></tr>
<tr class="separator:ae44a64a50ffea1498404e941eedfed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc06ae0f50e4d47da4de06426acb650"><td class="memItemLeft" align="right" valign="top">ThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#afcc06ae0f50e4d47da4de06426acb650">getThreadId</a> () const</td></tr>
<tr class="separator:afcc06ae0f50e4d47da4de06426acb650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a90d154b32b3a550f7a2670536bd02"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a65a90d154b32b3a550f7a2670536bd02">getAffinity</a> () const</td></tr>
<tr class="separator:a65a90d154b32b3a550f7a2670536bd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748172277e5241c0f7c217d35e550579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#a748172277e5241c0f7c217d35e550579">setAffinity</a> (uint64_t)</td></tr>
<tr class="separator:a748172277e5241c0f7c217d35e550579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0195c05a86b559d1f1fc8cb26fdd242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ac0195c05a86b559d1f1fc8cb26fdd242">terminate</a> (unsigned int exitCode=0)</td></tr>
<tr class="separator:ac0195c05a86b559d1f1fc8cb26fdd242"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac4a0c4c1899348c015c92a265759c68d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ac4a0c4c1899348c015c92a265759c68d">sleep</a> (const unsigned int millis)</td></tr>
<tr class="separator:ac4a0c4c1899348c015c92a265759c68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac482d6212ef6489a3455b0b5db43787b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ac482d6212ef6489a3455b0b5db43787b">yield</a> (YieldPolicy yp=YP_ANY_THREAD_SAME_PROCESSOR)</td></tr>
<tr class="separator:ac482d6212ef6489a3455b0b5db43787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860adb1878011327090fcc319d8762c"><td class="memItemLeft" align="right" valign="top">constexpr static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1core_1_1_thread.html#ac860adb1878011327090fcc319d8762c">getMinimunSleepTime</a> ()</td></tr>
<tr class="separator:ac860adb1878011327090fcc319d8762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a15aad542b2dd434bed233e51a50c4790"><td class="memItemLeft" align="right" valign="top"><a id="a15aad542b2dd434bed233e51a50c4790"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_threadProc</b> (void *param)</td></tr>
<tr class="separator:a15aad542b2dd434bed233e51a50c4790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Platform-independent thread implementation. <br  />
 </p>
<dl class="section note"><dt>Note</dt><dd>Threads are always created as <em>suspended</em>, and once starte are not suspended again by default when there are no any task to execute. This can be changed at will via setSuspendWhenNoTasks. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Some of these features may not be present on certain platforms, or may have specific requirements.</dd></dl>
<p>Please note that it's generally better to inherit from Thread_Impl insted of <a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a> directly, as it provides a few off-the-shelf features like task execution and few more things. <a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a> can of course be inherited, but will require additional programming to handle things safely. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8dd5fa37265e74107c20acac3d6e33f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd5fa37265e74107c20acac3d6e33f5">&#9670;&nbsp;</a></span>Thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mel::core::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the main thread routine. Calling this function will force the main thread routine (Thread::run) to be spawned and will return automatically just after doing so.<br  />
 The thread will keep runing in background until Thread::run finishes.<br  />
 <a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a> status can be queried meanwhile through <a class="el" href="classmel_1_1core_1_1_thread.html#ae44a64a50ffea1498404e941eedfed0c">Thread::isRunning</a>, and the final result obtained via <a class="el" href="classmel_1_1core_1_1_thread.html#a48aef994ca33536894e6b15c8adc8c3a">Thread::getResult</a>, once it finishes.<br  />
 Callers are encouraged to allways call <a class="el" href="classmel_1_1core_1_1_thread.html#a32a9ffeece50097f4eafa9f161988bef">Thread::join</a> before attempting to query the result value or even exiting the main application. </p>

</div>
</div>
<a id="a6f6e151220c5b492718e24795844f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6e151220c5b492718e24795844f18c">&#9670;&nbsp;</a></span>~Thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mel::core::Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new thread with the given name. New threads are always created in a suspended state, meaning no actual thread process will be actually executed until Thread::start is invoked. </p><dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a> should be only deleted when is sure it's finished (see terminate and join) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65a90d154b32b3a550f7a2670536bd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a90d154b32b3a550f7a2670536bd02">&#9670;&nbsp;</a></span>getAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mel::core::Thread::getAffinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get thread state </p><dl class="section return"><dt>Returns</dt><dd>the thread's current state returns if a terminate request is done (mEnd == true) </dd></dl>

</div>
</div>
<a id="ac860adb1878011327090fcc319d8762c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac860adb1878011327090fcc319d8762c">&#9670;&nbsp;</a></span>getMinimunSleepTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static unsigned mel::core::Thread::getMinimunSleepTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return minimun time(msecs) the system will wait with accuracy. it depends on underlying OS and hardware, but traditionally it's about 10-15 msecs </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>for the moment we will return a fixed contant depending on platform </dd></dl>

</div>
</div>
<a id="ac5839512d902b624b1027d22bc7730fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5839512d902b624b1027d22bc7730fc">&#9670;&nbsp;</a></span>getPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemel_1_1core.html#a09ec81fbf60f4c62e32529b58234f82f">ThreadPriority</a> mel::core::Thread::getPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query thread's current priority. </p><dl class="section return"><dt>Returns</dt><dd>the priority of the thread </dd></dl>

</div>
</div>
<a id="a48aef994ca33536894e6b15c8adc8c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48aef994ca33536894e6b15c8adc8c3a">&#9670;&nbsp;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mel::core::Thread::getResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the thread execution result. </p><dl class="section return"><dt>Returns</dt><dd>the requested result, that will only be meaningful if the thread already finished. The meaning (if any) of the returned value is defined by the concrete subclass implementing the thread. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmel_1_1core_1_1_thread.html#a32a9ffeece50097f4eafa9f161988bef">join</a>, <a class="el" href="classmel_1_1core_1_1_thread.html#ae44a64a50ffea1498404e941eedfed0c">isRunning</a> </dd></dl>

</div>
</div>
<a id="afcc06ae0f50e4d47da4de06426acb650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc06ae0f50e4d47da4de06426acb650">&#9670;&nbsp;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ThreadId mel::core::Thread::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return handle for this thread </p>

</div>
</div>
<a id="ae44a64a50ffea1498404e941eedfed0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44a64a50ffea1498404e941eedfed0c">&#9670;&nbsp;</a></span>isRunning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mel::core::Thread::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get thread's running status </p><dl class="section return"><dt>Returns</dt><dd>true if the thread is still running. false otherwise </dd></dl>

</div>
</div>
<a id="a32a9ffeece50097f4eafa9f161988bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a9ffeece50097f4eafa9f161988bef">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mel::core::Thread::join </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>millis</em> = <code>0xFFFFFFFF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces the caller to wait for thread completion. Calling this method will cause the calling thread to be wait until <a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a>:run finishes or the timeout expires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millis</td><td>maximum milliseconds to wait for the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread finished. false if timeout </dd></dl>

</div>
</div>
<a id="a748172277e5241c0f7c217d35e550579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748172277e5241c0f7c217d35e550579">&#9670;&nbsp;</a></span>setAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mel::core::Thread::setAffinity </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>no est� protegido frente a llamada con el hilo iniciandose </dd></dl>

</div>
</div>
<a id="a3ac5fe6b306866f66da2d65ad79455ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac5fe6b306866f66da2d65ad79455ec">&#9670;&nbsp;</a></span>setPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mel::core::Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemel_1_1core.html#a09ec81fbf60f4c62e32529b58234f82f">ThreadPriority</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes thread priority. May not be available in some platforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the new priority to be set. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4a0c4c1899348c015c92a265759c68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a0c4c1899348c015c92a265759c68d">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mel::core::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>millis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forces the calling thread to sleep. Calling this method ensures the OS will schedule some CPU for any pending processes and threads that need attention.<br  />
 NOTE: on some platforms, calling sleep(0) may cause the call to be completely ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millis</td><td>the number of milliseconds to sleep for. The actual sleep time may depend on each platform, but you can expect a granularity not finer than 10ms, meaning sleep(1) will make the thread sleep for almost the same time as sleep(10). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0195c05a86b559d1f1fc8cb26fdd242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0195c05a86b559d1f1fc8cb26fdd242">&#9670;&nbsp;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mel::core::Thread::terminate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>exitCode</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces thread termination Use with extreme caution; this method exists but it should rarely be used; it's always safer to invoke terminatRequest and wait for the <a class="el" href="classmel_1_1core_1_1_thread.html" title="Platform-independent thread implementation.">Thread</a> to terminate "naturally", instead of forcing it to quite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exitCode</td><td>the exit code for the terminated thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac482d6212ef6489a3455b0b5db43787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac482d6212ef6489a3455b0b5db43787b">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mel::core::Thread::yield </td>
          <td>(</td>
          <td class="paramtype">YieldPolicy&#160;</td>
          <td class="paramname"><em>yp</em> = <code>YP_ANY_THREAD_SAME_PROCESSOR</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forces the calling thread to yield execution. This may have slight different effects depending on the platform, but theoretically the execution is yielded only to threads in the same process as the caller.<br  />
 Calling this method may not force the OS to schedule any CPU time for any pending processes different that the caller. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/mel/include/core/<a class="el" href="_thread_8h_source.html">Thread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemel.html">mel</a></li><li class="navelem"><a class="el" href="namespacemel_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classmel_1_1core_1_1_thread.html">Thread</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
