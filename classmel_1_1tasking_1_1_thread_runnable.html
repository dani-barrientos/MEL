<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: mel::tasking::ThreadRunnable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemel.html">mel</a></li><li class="navelem"><a class="el" href="namespacemel_1_1tasking.html">tasking</a></li><li class="navelem"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmel_1_1tasking_1_1_thread_runnable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mel::tasking::ThreadRunnable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread with <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> behaviour.  
 <a href="classmel_1_1tasking_1_1_thread_runnable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_runnable_8h_source.html">ThreadRunnable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mel::tasking::ThreadRunnable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmel_1_1tasking_1_1_thread_runnable.png" usemap="#mel::tasking::ThreadRunnable_map" alt=""/>
  <map id="mel::tasking::ThreadRunnable_map" name="mel::tasking::ThreadRunnable_map">
<area href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o..." alt="mel::tasking::Runnable" shape="rect" coords="0,0,175,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af090b21adbd3adef079f79ef687ea3ab"><td class="memItemLeft" align="right" valign="top"><a id="af090b21adbd3adef079f79ef687ea3ab"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EThreadState</b> { <br />
&#160;&#160;<b>THREAD_INIT</b> = binary&lt;1&gt;::value
, <b>THREAD_RUNNING</b> = binary&lt;10&gt;::value
, <b>THREAD_SUSPENDED</b> = binary&lt;100&gt;::value
, <b>THREAD_FINISHING</b> = binary&lt;1000&gt;::value
, <br />
&#160;&#160;<b>THREAD_FINISHING_DONE</b> = binary&lt;10000&gt;::value
, <b>THREAD_FINISHED</b> = binary&lt;100000&gt;::value
<br />
 }</td></tr>
<tr class="separator:af090b21adbd3adef079f79ef687ea3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ac804f2130b3895f16a2dda96be560b"><td class="memItemLeft" align="right" valign="top"><a id="a0ac804f2130b3895f16a2dda96be560b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a0ac804f2130b3895f16a2dda96be560b">start</a> ()</td></tr>
<tr class="memdesc:a0ac804f2130b3895f16a2dda96be560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Thread Internally calls Runnablle::processTask in an infinite loop, with some other check for performance and state control virtual protected onRun is called before thread loop is set just in case children need to do custom job at that moment. <br /></td></tr>
<tr class="separator:a0ac804f2130b3895f16a2dda96be560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b36bb031cb4aac19a3badbafc5659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a753b36bb031cb4aac19a3badbafc5659">join</a> (unsigned int millis=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a753b36bb031cb4aac19a3badbafc5659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a join on the underlying Thread.  <a href="classmel_1_1tasking_1_1_thread_runnable.html#a753b36bb031cb4aac19a3badbafc5659">More...</a><br /></td></tr>
<tr class="separator:a753b36bb031cb4aac19a3badbafc5659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68032f585bdf9b2dd53f43a5b6b2a96"><td class="memItemLeft" align="right" valign="top"><a id="af68032f585bdf9b2dd53f43a5b6b2a96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setAffinity</b> (uint64_t aff)</td></tr>
<tr class="separator:af68032f585bdf9b2dd53f43a5b6b2a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655983125608fea8480cc1a8d515d97d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a655983125608fea8480cc1a8d515d97d">suspend</a> ()</td></tr>
<tr class="separator:a655983125608fea8480cc1a8d515d97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57ce772628d0d3f50f3f9bd72344152"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#ab57ce772628d0d3f50f3f9bd72344152">resume</a> ()</td></tr>
<tr class="separator:ab57ce772628d0d3f50f3f9bd72344152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66eca4130c33b77143def5806c4d7dd"><td class="memItemLeft" align="right" valign="top"><a id="ae66eca4130c33b77143def5806c4d7dd"></a>
EThreadState&#160;</td><td class="memItemRight" valign="bottom"><b>getState</b> () const</td></tr>
<tr class="separator:ae66eca4130c33b77143def5806c4d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1beda2360e89f885cd8baffab747e"><td class="memItemLeft" align="right" valign="top"><a id="ab3f1beda2360e89f885cd8baffab747e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>terminate</b> ()</td></tr>
<tr class="separator:ab3f1beda2360e89f885cd8baffab747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb278386e790b498bdec865ba22fd466"><td class="memItemLeft" align="right" valign="top"><a id="acb278386e790b498bdec865ba22fd466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getTerminateRequest</b> ()</td></tr>
<tr class="separator:acb278386e790b498bdec865ba22fd466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6259713eeceb4f7881c399029041d8"><td class="memItemLeft" align="right" valign="top"><a id="a0d6259713eeceb4f7881c399029041d8"></a>
inline ::mel::core::ThreadId&#160;</td><td class="memItemRight" valign="bottom"><b>getOwnerThreadId</b> () const</td></tr>
<tr class="separator:a0d6259713eeceb4f7881c399029041d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a046d4ea86599c3cb091bd56a95de15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a6a046d4ea86599c3cb091bd56a95de15">setOwnerThreadId</a> (mel::core::ThreadId tid)</td></tr>
<tr class="separator:a6a046d4ea86599c3cb091bd56a95de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3ef27a129b113b00a0c40cee7090e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a34e3ef27a129b113b00a0c40cee7090e">setDefaultFactory</a> (<a class="el" href="classmel_1_1tasking_1_1_process_factory.html">ProcessFactory</a> *factory)</td></tr>
<tr class="memdesc:a34e3ef27a129b113b00a0c40cee7090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change default factory used to create task through <a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">post</a> and <a class="el" href="classmel_1_1tasking_1_1_runnable.html#ad890610e8fbbe03fafea4804813cd3b0">fireAndForget</a>.  <a href="classmel_1_1tasking_1_1_runnable.html#a34e3ef27a129b113b00a0c40cee7090e">More...</a><br /></td></tr>
<tr class="separator:a34e3ef27a129b113b00a0c40cee7090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761ffdc2fc076acbc40c6b3f9d83ff7"><td class="memItemLeft" align="right" valign="top"><a id="ac761ffdc2fc076acbc40c6b3f9d83ff7"></a>
const <a class="el" href="classmel_1_1tasking_1_1_process_factory.html">ProcessFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#ac761ffdc2fc076acbc40c6b3f9d83ff7">getDefaultFactory</a> () const</td></tr>
<tr class="memdesc:ac761ffdc2fc076acbc40c6b3f9d83ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current default factory for tasks. <br /></td></tr>
<tr class="separator:ac761ffdc2fc076acbc40c6b3f9d83ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775fa406358dc7b798116ab68473c037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a775fa406358dc7b798116ab68473c037">postTask</a> (std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt; process, unsigned int startTime=0)</td></tr>
<tr class="separator:a775fa406358dc7b798116ab68473c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513abe2b1af17b963b1262bfa271190"><td class="memTemplParams" colspan="2">template&lt;class AllocatorType  = ::mel::tasking::DefaultAllocator, class F , class KF  = const std::function&lt;bool()&gt;&amp;&gt; </td></tr>
<tr class="memitem:af513abe2b1af17b963b1262bfa271190"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">post</a> (F &amp;&amp;task_proc, KF &amp;&amp;killFunction=<a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a>, unsigned int period=0, unsigned int startTime=0)</td></tr>
<tr class="separator:af513abe2b1af17b963b1262bfa271190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad890610e8fbbe03fafea4804813cd3b0"><td class="memTemplParams" colspan="2">template&lt;class AllocatorType  = ::mel::tasking::DefaultAllocator, class F , class KF  = const std::function&lt;bool()&gt;&amp;&gt; </td></tr>
<tr class="memitem:ad890610e8fbbe03fafea4804813cd3b0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#ad890610e8fbbe03fafea4804813cd3b0">fireAndForget</a> (F &amp;&amp;task_proc, unsigned int startTime=0, KF &amp;&amp;killFunction=<a class="el" href="classmel_1_1tasking_1_1_runnable.html#aa13d5da09bbc07193a5b3a4992165f3d">killTrue</a>)</td></tr>
<tr class="memdesc:ad890610e8fbbe03fafea4804813cd3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient function to post no periodic task with signature void f()  <a href="classmel_1_1tasking_1_1_runnable.html#ad890610e8fbbe03fafea4804813cd3b0">More...</a><br /></td></tr>
<tr class="separator:ad890610e8fbbe03fafea4804813cd3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cdb4e5ff3ac532059b5a0ca6a0a49b"><td class="memTemplParams" colspan="2">template&lt;class TRet , class F , class KF  = const std::function&lt;bool()&gt;&amp;&gt; </td></tr>
<tr class="memitem:a02cdb4e5ff3ac532059b5a0ca6a0a49b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a02cdb4e5ff3ac532059b5a0ca6a0a49b">execute</a> (F &amp;&amp;function, KF &amp;&amp;killFunction=<a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a>) noexcept</td></tr>
<tr class="memdesc:a02cdb4e5ff3ac532059b5a0ca6a0a49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a function in a context of the <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a>. If this <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> is in the same thread than caller then, depending on forcepost parameter, the functor will be executed directly (so Future&lt;TRet&gt; will be always available at return) or posted (so caller will need to wait on this Future or whatever other mechanism)  <a href="classmel_1_1tasking_1_1_runnable.html#a02cdb4e5ff3ac532059b5a0ca6a0a49b">More...</a><br /></td></tr>
<tr class="separator:a02cdb4e5ff3ac532059b5a0ca6a0a49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb42def1c0524e42f9e6a33f3fabfdfb"><td class="memTemplParams" colspan="2">template&lt;class TRet , class F , class KF  = const std::function&lt;bool()&gt;&amp;&gt; </td></tr>
<tr class="memitem:acb42def1c0524e42f9e6a33f3fabfdfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#acb42def1c0524e42f9e6a33f3fabfdfb">execute</a> (F &amp;&amp;function, <a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt;, KF &amp;&amp;killFunction=<a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a>) noexcept</td></tr>
<tr class="memdesc:acb42def1c0524e42f9e6a33f3fabfdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload where output Future is given With this overload the given Future is fille with result from function.  <a href="classmel_1_1tasking_1_1_runnable.html#acb42def1c0524e42f9e6a33f3fabfdfb">More...</a><br /></td></tr>
<tr class="separator:acb42def1c0524e42f9e6a33f3fabfdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858692ee28e2526a797a6178206c7df5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmel_1_1tasking_1_1_process_scheduler.html">ProcessScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a858692ee28e2526a797a6178206c7df5">getScheduler</a> () const</td></tr>
<tr class="separator:a858692ee28e2526a797a6178206c7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17130341324f5f5f5646a9a5be8416ee"><td class="memItemLeft" align="right" valign="top"><a id="a17130341324f5f5f5646a9a5be8416ee"></a>
<a class="el" href="classmel_1_1tasking_1_1_process_scheduler.html">ProcessScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> ()</td></tr>
<tr class="separator:a17130341324f5f5f5646a9a5be8416ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4648740579cca61ddd8ae5df2932302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#ad4648740579cca61ddd8ae5df2932302">setTimer</a> (std::shared_ptr&lt; <a class="el" href="classmel_1_1core_1_1_timer.html">Timer</a> &gt; timer)</td></tr>
<tr class="separator:ad4648740579cca61ddd8ae5df2932302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd99f0ac1fe1987a7c5370b71df28c5d"><td class="memItemLeft" align="right" valign="top"><a id="abd99f0ac1fe1987a7c5370b71df28c5d"></a>
const std::shared_ptr&lt; <a class="el" href="classmel_1_1core_1_1_timer.html">Timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTimer</b> () const</td></tr>
<tr class="separator:abd99f0ac1fe1987a7c5370b71df28c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feca3518eae92d16e671dc0f0dc6fa6"><td class="memItemLeft" align="right" valign="top"><a id="a7feca3518eae92d16e671dc0f0dc6fa6"></a>
std::shared_ptr&lt; <a class="el" href="classmel_1_1core_1_1_timer.html">Timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTimer</b> ()</td></tr>
<tr class="separator:a7feca3518eae92d16e671dc0f0dc6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b10e9efe00257f8b9ad9fa47a00636"><td class="memItemLeft" align="right" valign="top"><a id="ac1b10e9efe00257f8b9ad9fa47a00636"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getPendingTaskCount</b> () const</td></tr>
<tr class="separator:ac1b10e9efe00257f8b9ad9fa47a00636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828558c1c33f4c70337b1616e43cae99"><td class="memItemLeft" align="right" valign="top"><a id="a828558c1c33f4c70337b1616e43cae99"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getActiveTaskCount</b> () const</td></tr>
<tr class="separator:a828558c1c33f4c70337b1616e43cae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac121ea4d2f7f6ec9b61d5f9f6fb65829"><td class="memItemLeft" align="right" valign="top"><a id="ac121ea4d2f7f6ec9b61d5f9f6fb65829"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxPoolSize</b> () const</td></tr>
<tr class="separator:ac121ea4d2f7f6ec9b61d5f9f6fb65829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abca826d6381b0f40b3281f2113baa230"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#abca826d6381b0f40b3281f2113baa230">create</a> (bool autoRun=true, <a class="el" href="structmel_1_1tasking_1_1_runnable_1_1_runnable_creation_options.html">Runnable::RunnableCreationOptions</a> opts=sDefaultOpts)</td></tr>
<tr class="memdesc:abca826d6381b0f40b3281f2113baa230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html" title="Thread with Runnable behaviour.">ThreadRunnable</a>.  <a href="classmel_1_1tasking_1_1_thread_runnable.html#abca826d6381b0f40b3281f2113baa230">More...</a><br /></td></tr>
<tr class="separator:abca826d6381b0f40b3281f2113baa230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6599cc178733e5d47b6ecf8841688468"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a6599cc178733e5d47b6ecf8841688468">getCurrentThreadRunnable</a> ()</td></tr>
<tr class="separator:a6599cc178733e5d47b6ecf8841688468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c99a027a3cd23f477c7d1887cb8dc8"><td class="memItemLeft" align="right" valign="top"><a id="aa7c99a027a3cd23f477c7d1887cb8dc8"></a>
static <a class="el" href="classmel_1_1tasking_1_1_runnable.html">Runnable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentRunnable</b> ()</td></tr>
<tr class="separator:aa7c99a027a3cd23f477c7d1887cb8dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab98594ee5c8d75a78b3774c27b2671b7"><td class="memItemLeft" align="right" valign="top"><a id="ab98594ee5c8d75a78b3774c27b2671b7"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_POOL_SIZE</b> = 512</td></tr>
<tr class="separator:ab98594ee5c8d75a78b3774c27b2671b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13d5da09bbc07193a5b3a4992165f3d"><td class="memItemLeft" align="right" valign="top"><a id="aa13d5da09bbc07193a5b3a4992165f3d"></a>
static std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#aa13d5da09bbc07193a5b3a4992165f3d">killTrue</a></td></tr>
<tr class="memdesc:aa13d5da09bbc07193a5b3a4992165f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to automatically kill process when receiving kill signal <br /></td></tr>
<tr class="separator:aa13d5da09bbc07193a5b3a4992165f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8321dac1a4a8f7415a5fdbcb5e540e62"><td class="memItemLeft" align="right" valign="top"><a id="a8321dac1a4a8f7415a5fdbcb5e540e62"></a>
static std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a></td></tr>
<tr class="memdesc:a8321dac1a4a8f7415a5fdbcb5e540e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to reject kill when receiving kill signal <br /></td></tr>
<tr class="separator:a8321dac1a4a8f7415a5fdbcb5e540e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a40875f72ac18980f9c4d0228669294b2"><td class="memItemLeft" align="right" valign="top"><a id="a40875f72ac18980f9c4d0228669294b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a40875f72ac18980f9c4d0228669294b2">ThreadRunnable</a> (<a class="el" href="structmel_1_1tasking_1_1_runnable_1_1_runnable_creation_options.html">Runnable::RunnableCreationOptions</a> opts=sDefaultOpts)</td></tr>
<tr class="memdesc:a40875f72ac18980f9c4d0228669294b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread with an empty loop, that continuosly processes posted tasks. <br /></td></tr>
<tr class="separator:a40875f72ac18980f9c4d0228669294b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49cb46462a825db91af836f19710f88"><td class="memItemLeft" align="right" valign="top"><a id="af49cb46462a825db91af836f19710f88"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#af49cb46462a825db91af836f19710f88">onStart</a> ()</td></tr>
<tr class="memdesc:af49cb46462a825db91af836f19710f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a0ac804f2130b3895f16a2dda96be560b" title="Start Thread Internally calls Runnablle::processTask in an infinite loop, with some other check for p...">start()</a> function Children can override it to add custom behaviour. <br /></td></tr>
<tr class="separator:af49cb46462a825db91af836f19710f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae905f6649afb62493019d381422701"><td class="memItemLeft" align="right" valign="top"><a id="a7ae905f6649afb62493019d381422701"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a7ae905f6649afb62493019d381422701">onThreadStart</a> ()</td></tr>
<tr class="memdesc:a7ae905f6649afb62493019d381422701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called one time at the start of the thread loop, so, already in this thread context Don't confuse with onStart,which is called when <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a0ac804f2130b3895f16a2dda96be560b" title="Start Thread Internally calls Runnablle::processTask in an infinite loop, with some other check for p...">start()</a> is called, so called on the <em>caller thread</em>^context. <br /></td></tr>
<tr class="separator:a7ae905f6649afb62493019d381422701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809406683351ab074afeffd66f982295"><td class="memItemLeft" align="right" valign="top"><a id="a809406683351ab074afeffd66f982295"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a809406683351ab074afeffd66f982295">onThreadEnd</a> ()</td></tr>
<tr class="memdesc:a809406683351ab074afeffd66f982295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when at the end of the thread loop. <br /></td></tr>
<tr class="separator:a809406683351ab074afeffd66f982295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049e3a138ee39e06d60561ed042a5a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#ac049e3a138ee39e06d60561ed042a5a4">onJoined</a> ()</td></tr>
<tr class="memdesc:ac049e3a138ee39e06d60561ed042a5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a753b36bb031cb4aac19a3badbafc5659">join()</a> when done.  <a href="classmel_1_1tasking_1_1_thread_runnable.html#ac049e3a138ee39e06d60561ed042a5a4">More...</a><br /></td></tr>
<tr class="separator:ac049e3a138ee39e06d60561ed042a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f14d72cbdcdc20a386db2666f9e7d4"><td class="memItemLeft" align="right" valign="top"><a id="a87f14d72cbdcdc20a386db2666f9e7d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onCycleEnd</b> ()</td></tr>
<tr class="separator:a87f14d72cbdcdc20a386db2666f9e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5f09f603b7c25d3f898171e7caf06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#ace5f09f603b7c25d3f898171e7caf06a">onPostTask</a> (std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt; process) override</td></tr>
<tr class="separator:ace5f09f603b7c25d3f898171e7caf06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739300ffe3746a01d7db62f4cb575ab6"><td class="memItemLeft" align="right" valign="top"><a id="a739300ffe3746a01d7db62f4cb575ab6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a739300ffe3746a01d7db62f4cb575ab6">processTasks</a> ()</td></tr>
<tr class="memdesc:a739300ffe3746a01d7db62f4cb575ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a controlled loop over the internal queue, executing pending tasks. This function must be called always from same place, without altering the stack. <br /></td></tr>
<tr class="separator:a739300ffe3746a01d7db62f4cb575ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread with <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> behaviour. </p>
<p>An instance of this class allow to receive task via <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> available functions. The thread will be paused if no active tasks in its scheduler, that means: there isn't any task or the tasks are in sleep state. One a task is posted or a task is awake, the thread continues processing Destruction of a <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html" title="Thread with Runnable behaviour.">ThreadRunnable</a> implies a join, waiting for the tasks to be completed. A kill signal is sent to all the tasks, but <em>not forced</em>, so is user's responsability to manage tasks correctly </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abca826d6381b0f40b3281f2113baa230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca826d6381b0f40b3281f2113baa230">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a>&gt; mel::tasking::ThreadRunnable::create </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRun</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmel_1_1tasking_1_1_runnable_1_1_runnable_creation_options.html">Runnable::RunnableCreationOptions</a>&#160;</td>
          <td class="paramname"><em>opts</em> = <code>sDefaultOpts</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html" title="Thread with Runnable behaviour.">ThreadRunnable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoRun</td><td>if false, thread will be created suspende (but really running). The reason to no call this parameter "createSuspended" is because legacy issues </td></tr>
    <tr><td class="paramname">opts</td><td>creation options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;ThreadRunnable&gt; </dd></dl>

</div>
</div>
<a id="acb42def1c0524e42f9e6a33f3fabfdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb42def1c0524e42f9e6a33f3fabfdfb">&#9670;&nbsp;</a></span>execute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TRet , class F , class KF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt; mel::tasking::Runnable::execute </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KF &amp;&amp;&#160;</td>
          <td class="paramname"><em>killFunction</em> = <code><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload where output Future is given With this overload the given Future is fille with result from function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Future where result must be put </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same future as out </dd></dl>

</div>
</div>
<a id="a02cdb4e5ff3ac532059b5a0ca6a0a49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cdb4e5ff3ac532059b5a0ca6a0a49b">&#9670;&nbsp;</a></span>execute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TRet , class F , class KF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1core_1_1_future.html">Future</a>&lt; TRet &gt; mel::tasking::Runnable::execute </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KF &amp;&amp;&#160;</td>
          <td class="paramname"><em>killFunction</em> = <code><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a function in a context of the <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a>. If this <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> is in the same thread than caller then, depending on forcepost parameter, the functor will be executed directly (so Future&lt;TRet&gt; will be always available at return) or posted (so caller will need to wait on this Future or whatever other mechanism) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Functor with signature TRet f() that will be executed in this <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">killFunction.</td><td>Functor with signature bool () used when kill is executed while doing function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad890610e8fbbe03fafea4804813cd3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad890610e8fbbe03fafea4804813cd3b0">&#9670;&nbsp;</a></span>fireAndForget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AllocatorType , class F , class KF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt; mel::tasking::Runnable::fireAndForget </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KF &amp;&amp;&#160;</td>
          <td class="paramname"><em>killFunction</em> = <code><a class="el" href="classmel_1_1tasking_1_1_runnable.html#aa13d5da09bbc07193a5b3a4992165f3d">killTrue</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient function to post no periodic task with signature void f() </p>
<p>see <a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">post</a> for considerations con template parameter AllocatorType </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_proc</td><td>functor with signature void f(void) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">killFunction.</td><td>Functor with signature bool () used when kill is executed while doing function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6599cc178733e5d47b6ecf8841688468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6599cc178733e5d47b6ecf8841688468">&#9670;&nbsp;</a></span>getCurrentThreadRunnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a>* mel::tasking::ThreadRunnable::getCurrentThreadRunnable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return current executing <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html" title="Thread with Runnable behaviour.">ThreadRunnable</a>. nullptr if any. result can be NULL if current executing thread is not a Thread type (for example, main application thread or thread created through API functions </p>

</div>
</div>
<a id="a858692ee28e2526a797a6178206c7df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858692ee28e2526a797a6178206c7df5">&#9670;&nbsp;</a></span>getScheduler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmel_1_1tasking_1_1_process_scheduler.html">ProcessScheduler</a> &amp; mel::tasking::Runnable::getScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a given task to be acomplished </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">taskId</td><td>the task to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task has already been executed. false otherwise </dd></dl>

</div>
</div>
<a id="a753b36bb031cb4aac19a3badbafc5659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753b36bb031cb4aac19a3badbafc5659">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mel::tasking::ThreadRunnable::join </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>millis</em> = <code>0xFFFFFFFF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a join on the underlying Thread. </p>
<p>when join is done, the function <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#ac049e3a138ee39e06d60561ed042a5a4">onJoined</a> is called, as a way to notify children </p>

</div>
</div>
<a id="ac049e3a138ee39e06d60561ed042a5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac049e3a138ee39e06d60561ed042a5a4">&#9670;&nbsp;</a></span>onJoined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mel::tasking::ThreadRunnable::onJoined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a753b36bb031cb4aac19a3badbafc5659">join()</a> when done. </p>
<p>Intended for specializaations to be notified </p>

</div>
</div>
<a id="ace5f09f603b7c25d3f898171e7caf06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5f09f603b7c25d3f898171e7caf06a">&#9670;&nbsp;</a></span>onPostTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mel::tasking::ThreadRunnable::onPostTask </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt;&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>overriden from <a class="el" href="classmel_1_1tasking_1_1_runnable.html" title="A class representing a &quot;running&quot; task, with added functionality to post events requesting execution o...">Runnable</a> </p>

<p>Reimplemented from <a class="el" href="classmel_1_1tasking_1_1_runnable.html">mel::tasking::Runnable</a>.</p>

</div>
</div>
<a id="af513abe2b1af17b963b1262bfa271190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513abe2b1af17b963b1262bfa271190">&#9670;&nbsp;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AllocatorType , class F , class KF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt; mel::tasking::Runnable::post </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KF &amp;&amp;&#160;</td>
          <td class="paramname"><em>killFunction</em> = <code><a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>period</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Posts a new execution request over a functor The execution is NOT guaranteed to be taken into account inmediatly. By default, a ::mel::tasking::_private::RunnableTask is created, which is intended to be used with a custom memory manager for performance reasons. Users can provide their own AllocatorType class to change the way the underlying <a class="el" href="classmel_1_1tasking_1_1_process.html" title="A periodic task, implementing a microthread.">Process</a> is created, either by creating a custom specialization of <a class="el" href="classmel_1_1tasking_1_1_generic_process.html">GenericProcess</a> or/and using a custom memory pool </p><dl class="section see"><dt>See also</dt><dd>RTMemPool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_proc</td><td>the functor to be executed. It has signature: bool (unsigned int msecs, Process*) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">killFunction.</td><td>Functor with signature bool () used when kill is executed while doing function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Milliseconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>milliseconds to begin task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the process created for this task </dd></dl>

</div>
</div>
<a id="a775fa406358dc7b798116ab68473c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775fa406358dc7b798116ab68473c037">&#9670;&nbsp;</a></span>postTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mel::tasking::Runnable::postTask </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> &gt;&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set callback to call when a task is added</p>
<p>Only one event, so you should get previous event to call chained (and free it) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functor.</td><td>With signature void f(Runnable*,Process*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>not thread safe. Now it's only protected to allow only to children Posts new execution request. Adds the request to the queue and generates a new internal task id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">process</td><td>structure containing execution data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer being the internal task id just created @internally, it calls protected onPostTask, so children can add custom behaviour </dd></dl>

</div>
</div>
<a id="ab57ce772628d0d3f50f3f9bd72344152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57ce772628d0d3f50f3f9bd72344152">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mel::tasking::ThreadRunnable::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts a previously suspended thread. </p><dl class="section return"><dt>Returns</dt><dd>the number of pending "suspend" operations before resume was called, or 0xFFFFFFFF if the operation was not successful. If the value returned is greater than 1, the thread is still suspended. NOTE: Calling this method has no effect on platforms others than Windows. </dd></dl>

</div>
</div>
<a id="a34e3ef27a129b113b00a0c40cee7090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3ef27a129b113b00a0c40cee7090e">&#9670;&nbsp;</a></span>setDefaultFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mel::tasking::Runnable::setDefaultFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1tasking_1_1_process_factory.html">ProcessFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change default factory used to create task through <a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">post</a> and <a class="el" href="classmel_1_1tasking_1_1_runnable.html#ad890610e8fbbe03fafea4804813cd3b0">fireAndForget</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>not multithread-safe. If tasks are being posted while this function is changed, it will reach to unpredictable results </dd></dl>

</div>
</div>
<a id="a6a046d4ea86599c3cb091bd56a95de15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a046d4ea86599c3cb091bd56a95de15">&#9670;&nbsp;</a></span>setOwnerThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mel::tasking::Runnable::setOwnerThreadId </td>
          <td>(</td>
          <td class="paramtype">mel::core::ThreadId&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Manually set the owner thread ID. Usually, the thread ID is automatically set when invoking ::run, but this allows the caller to set it up-front, just in case it's needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>the owner thread to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4648740579cca61ddd8ae5df2932302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4648740579cca61ddd8ae5df2932302">&#9670;&nbsp;</a></span>setTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mel::tasking::Runnable::setTimer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmel_1_1core_1_1_timer.html">Timer</a> &gt;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set timer to be used by internal scheduler If no Timer is given, a new Timer is created first time </p>

</div>
</div>
<a id="a655983125608fea8480cc1a8d515d97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655983125608fea8480cc1a8d515d97d">&#9670;&nbsp;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mel::tasking::ThreadRunnable::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the main thread routine to be suspended. If thread is no in THREAD_RUNNING, it hasn't effect </p><dl class="section return"><dt>Returns</dt><dd>the number of pending "suspend" operations performed so far, or 0 if the thread could not be suspended.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>. keep an eye on it because between state change to THREAD_PAUSED and real pause ther is a gap. because is's done through a post It could be fixed with SignalObjectAndWait in Windows but I don't know how to do it in POSIX </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/mel/include/tasking/<a class="el" href="_thread_runnable_8h_source.html">ThreadRunnable.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
