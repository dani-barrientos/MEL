<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: Execution System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('execution_system.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Execution System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Contents of this section:</p><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#usage_samples">Usage samples</a></li>
<li><a href="#error_management">Error management</a></li>
<li><a href="#perfect_forwarding">Perfect forwarding</a></li>
<li><a href="#work_flows">Work flows</a></li>
</ul>
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>The goal of this module is to provide a very high level API for task execution in a generic way, such that is not neccesary to know the underlying execution system. This <em>problem</em> it's becoming very important because the need to exploit the modern hardware. As the CPU speed is incrementing very slowly, the improvements in software development come from taking advantage of the parallel capacities, use of GPU as computational resource, distributed systems...So, it's necessary to provide new idioms to programmers such that doing this kind of tasks won't be a hell.</p>
<p><b>mel</b> provides clasical mechanism for concurrent/parallel programming: <a class="el" href="classmel_1_1core_1_1_thread.html">threads</a>, critical sections,...and no so classicals as the microthread system, which is described in another sections. These tools are enough for simple tasks. But there are two main problems:</p><ul>
<li>The way the user make the code will depend on the used tool: the code won't be the same if using a thread to launch a task or a microthread. Or, even worse, use the GPU or other systems</li>
<li>Doing complex tasks can be hard to express and the programmer will soon get lost in the code.</li>
</ul>
<p>For example, let's assume we want to execute a task <em>t1</em> in some thread, then, when the task is finished, execute another task <em>t2</em> and, when this is finished, execute two parallel tasks <em>t3</em> and <em>t4</em> in some thread pool. With the <em>basic</em> tools in mel, this is not so much hard, but a kind of mess. The code could be: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> fut = th1-&gt;execute&lt;<span class="keywordtype">void</span>&gt;([]()</div>
<div class="line">{</div>
<div class="line">   <span class="comment">//...task t1... </span></div>
<div class="line">}); </div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a>(fut); <span class="comment">//depending on the concrete situation where this code is running, maybe use some other mechanism as mel::tasking::waitForFutureMThread or ::mel::core::Future::subscribeCallback</span></div>
<div class="line">  <span class="comment">//now execute task t2</span></div>
<div class="line">  <span class="keyword">auto</span> fut2 = th1-&gt;execute&lt;<span class="keywordtype">void</span>&gt;([]()</div>
<div class="line">  {</div>
<div class="line">      <span class="comment">//...task t2... </span></div>
<div class="line">  }); </div>
<div class="line">  <span class="keyword">auto</span> res2 = <a class="code" href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a>(fut2);</div>
<div class="line">  <span class="comment">//now execute t3 and t4</span></div>
<div class="line">  ThreadPool::ThreadPoolOpts opts;      </div>
<div class="line">  ThreadPool myPool(opts);</div>
<div class="line">  ThreadPool::ExecutionOpts exopts;</div>
<div class="line">  <span class="keyword">auto</span> barrier = myPool.execute&lt;<span class="keywordtype">void</span>&gt;(exopts,</div>
<div class="line">      []()</div>
<div class="line">      {</div>
<div class="line">          <span class="comment">//..t3..</span></div>
<div class="line">      },</div>
<div class="line">      []()</div>
<div class="line">      {</div>
<div class="line">          <span class="comment">//..t4..</span></div>
<div class="line">      }</div>
<div class="line">  );</div>
<div class="line">  <a class="code" href="namespacemel_1_1core.html#ad0937af1a6401aa286a06dc047c21d70">mel::core::waitForBarrierThread</a>(barrier);</div>
<div class="line">  <span class="comment">//......</span></div>
<div class="line">}<span class="keywordflow">catch</span>(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...manage error..</span></div>
<div class="line">}  </div>
<div class="ttc" id="anamespacemel_1_1core_html_a104e002cdbc28f6e37b771760742e3b6"><div class="ttname"><a href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a></div><div class="ttdeci">::mel::core::WaitResult&lt; T &gt; waitForFutureThread(const mel::core::Future&lt; T &gt; &amp;f, unsigned int msecs=::mel::core::Event::EVENT_WAIT_INFINITE) noexcept(std::is_same&lt; ErrorType,::mel::core::WaitErrorNoException &gt;::value)</div><div class="ttdoc">Wait for a Future from a Thread</div><div class="ttdef"><b>Definition:</b> Thread.h:226</div></div>
<div class="ttc" id="anamespacemel_1_1core_html_ad0937af1a6401aa286a06dc047c21d70"><div class="ttname"><a href="namespacemel_1_1core.html#ad0937af1a6401aa286a06dc047c21d70">mel::core::waitForBarrierThread</a></div><div class="ttdeci">MEL_API ::mel::core::Event::EWaitCode waitForBarrierThread(const ::mel::parallelism::Barrier &amp;b, unsigned int msecs=Event::EVENT_WAIT_INFINITE)</div><div class="ttdoc">Wait for a barrier to activated in the context of a thread.</div></div>
</div><!-- fragment --><p> As can be seen, mel already provides high level tools to facilitate task execution. But, despite of that, it can be hard to manage a complex execution sequence. Think, for example, how to manage error in any point of the chain. And, of course, think how to resolve the same problem only with plain C++ threads...</p>
<p>Instead, with the <a class="el" href="namespacemel_1_1execution.html">execution system</a>, built on top of those functionalities, we could write something like: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);    </div>
<div class="line">execution::Executor&lt;Runnable&gt; exr(th1); <span class="comment">//Create executor based on ThreadRunnable</span></div>
<div class="line"><a class="code" href="structmel_1_1parallelism_1_1_thread_pool_1_1_thread_pool_opts.html">mel::parallelism::ThreadPool::ThreadPoolOpts</a> opts;</div>
<div class="line"><span class="keyword">auto</span> myPool = make_shared&lt;parallelism::ThreadPool&gt;(opts);</div>
<div class="line">parallelism::ThreadPool::ExecutionOpts exopts;</div>
<div class="line">execution::Executor&lt;parallelism::ThreadPool&gt; extp(myPool); <span class="comment">//create another executor based on ThreadPool</span></div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> res = mel::tasking::waitForFutureThread(</div>
<div class="line">        <a class="code" href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">mel::execution::launch</a>(ex, []()</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//...task t1...</span></div>
<div class="line">        })</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( []()</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//...task t2...</span></div>
<div class="line">        })</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#a9c2d394e1f670743253c44823c2e26fc">transfer</a>(extp)</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a>(</div>
<div class="line">            []()</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//... taks t3...</span></div>
<div class="line">            },</div>
<div class="line">            []()</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//... taks t4...</span></div>
<div class="line">            }</div>
<div class="line">        )</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">}<span class="keywordflow">catch</span>(...)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="anamespacemel_1_1execution_html_a460fabb63e024b68842b3f2575373439"><div class="ttname"><a href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &gt; &gt; next(ExFuture&lt; ExecutorAgent, TArg &gt; source, F f)</div><div class="ttdoc">Attach a functor to execute when input fut is complete Given functor will be executed inf the input E...</div><div class="ttdef"><b>Definition:</b> Executor.h:129</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_a9c2d394e1f670743253c44823c2e26fc"><div class="ttname"><a href="namespacemel_1_1execution.html#a9c2d394e1f670743253c44823c2e26fc">mel::execution::transfer</a></div><div class="ttdeci">ExFuture&lt; NewExecutorAgent, TRet &gt; transfer(ExFuture&lt; OldExecutorAgent, TRet &gt; source, Executor&lt; NewExecutorAgent &gt; newAgent)</div><div class="ttdoc">Transfer given ExFuture to a different executor This way, continuations can be chained but executed i...</div><div class="ttdef"><b>Definition:</b> Executor.h:208</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_aa15811b945ee6be8ccbfb93fdd66baa7"><div class="ttname"><a href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">mel::execution::launch</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, std::invoke_result_t&lt; F &gt; &gt; launch(Executor&lt; ExecutorAgent &gt; ex, F &amp;&amp;f)</div><div class="ttdoc">Launch given functor in given executor.</div><div class="ttdef"><b>Definition:</b> Executor.h:48</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_aa452862b7a1d169e5a3be1e9fa1b66f2"><div class="ttname"><a href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, TArg &gt; parallel(ExFuture&lt; ExecutorAgent, TArg &gt; source, FTypes... functions)</div><div class="ttdoc">Execute given functions in a (possibly, depending on concrete executor) parallel way If an exception ...</div><div class="ttdef"><b>Definition:</b> Executor.h:372</div></div>
<div class="ttc" id="astructmel_1_1parallelism_1_1_thread_pool_1_1_thread_pool_opts_html"><div class="ttname"><a href="structmel_1_1parallelism_1_1_thread_pool_1_1_thread_pool_opts.html">mel::parallelism::ThreadPool::ThreadPoolOpts</a></div><div class="ttdef"><b>Definition:</b> ThreadPool.h:48</div></div>
</div><!-- fragment --><p> As can be seen in the example code, the expresiveness and flexibility of this mechanism is far superior. The used executor can be any executor type, the <em>only thing</em> to do (of course, it can be difficult) is to implement the neccesary parts of a new execution system when neccesary (for example, an execution system based on GPU processing). Mel provides three types of executors, the ones used in this example: a <a class="el" href="namespacemel_1_1execution.html#a0c008697e5e12a69ade00e0fd0ae3254">RunnableExecutor</a> based on <a class="el" href="classmel_1_1tasking_1_1_runnable.html">runnables</a>, a <a class="el" href="namespacemel_1_1execution.html#a5e0ddd0955796bd634b11035be2161d7">ThreadPoolExecutor</a> based on <a class="el" href="classmel_1_1parallelism_1_1_thread_pool.html">a thread pool</a> and an <a class="el" href="namespacemel_1_1execution.html#adee1d4b15ec1985a4bde524b726babaa">InlineExecutor</a> which behavess exactly as if code is written inline (so, no executor at all). There is another <a class="el" href="namespacemel_1_1execution.html#a4931739bc623cfa66e368b1f6ca8466e">mel::execution::NaiveInlineExecutor</a> included as a demostration: its implementation is straigthforward but not as much efficient as the <em>InlineExecutor</em>.</p>
<p>The <em>RunnableExecutor</em> and <em>ThreadPoolExecutor</em> have microthread capabilities, meaning that the tasks executed in any of them can take advange of mel's cooperative multitasking (see ::Tasking::Process). Some examples will be provided in the next sections trying to describe al the functionalities with simple cases, and showing all the power of this system. As a note, the examples will be shown using de pipe ('|') operator, but the <em>classic</em> form could be used, althoguh is less expresive and hard to read: </p><div class="fragment"><div class="line">[...same as previous example..]</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> res = mel::tasking::waitForFutureThread(</div>
<div class="line">        <a class="code" href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a>(</div>
<div class="line">            <a class="code" href="namespacemel_1_1execution.html#a9c2d394e1f670743253c44823c2e26fc">transfer</a>(</div>
<div class="line">                <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( </div>
<div class="line">                        <a class="code" href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">mel::execution::launch</a>(ex, []()</div>
<div class="line">                        {</div>
<div class="line">                            <span class="comment">//...task t1...</span></div>
<div class="line">                        }),</div>
<div class="line">                    []()</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">//...task t2...</span></div>
<div class="line">                    }</div>
<div class="line">                ),extp),</div>
<div class="line">            []()</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//... taks t3...</span></div>
<div class="line">            },</div>
<div class="line">            []()</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//... taks t4...</span></div>
<div class="line">            }               </div>
<div class="line">        )</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}<span class="keywordflow">catch</span>(...)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="usage_samples"></a>
Usage samples</h2>
<p>The following samples are for educational purposes only. This means that the tasks acomplished may not make any sense or that they aren't done in the best possible way. The goal is to show the different functionalities and its power. All the samples are done without worrying on the underlying executor, and implemented as template functions.</p>
<p>This functions could be used as: </p><div class="fragment"><div class="line"><span class="comment">//create a RunnableExecutor</span></div>
<div class="line"><span class="keyword">auto</span> th = ThreadRunnable::create(<span class="keyword">true</span>);         </div>
<div class="line">execution::Executor&lt;Runnable&gt; exr(th);</div>
<div class="line">exr.setOpts({<span class="keyword">true</span>,<span class="keyword">false</span>});</div>
<div class="line">_sampleBasic(exr); <span class="comment">//call sample with the RunnableExecutor</span></div>
<div class="line"><span class="comment">//now create an executor based on a ThreadPool</span></div>
<div class="line">parallelism::ThreadPool::ThreadPoolOpts opts;</div>
<div class="line"><span class="keyword">auto</span> myPool = make_shared&lt;parallelism::ThreadPool&gt;(opts);</div>
<div class="line">parallelism::ThreadPool::ExecutionOpts exopts;</div>
<div class="line">execution::Executor&lt;parallelism::ThreadPool&gt; extp(myPool);</div>
<div class="line">extp.setOpts({<span class="keyword">true</span>,<span class="keyword">true</span>});  </div>
<div class="line">_sampleBasic(extp); <span class="comment">//use same sample with this new executor</span></div>
<div class="line"><span class="comment">//now an InlineExecutor, which is roughly the same as executing the code directly</span></div>
<div class="line">execution::InlineExecutor exInline;</div>
<div class="line">_sampleBasic(exInline); <span class="comment">//use same sample with this new executor</span></div>
</div><!-- fragment --><ul>
<li><a href="#basic_sample">Basic sample</a></li>
<li><a href="#using_references">Using references</a></li>
<li><a href="#chaging_executor">Changing executor</a></li>
<li><a href="#converging_jobs">Converging jobs</a></li>
<li><a href="#advance_example">Advanced example</a></li>
</ul>
<h3><a class="anchor" id="basic_sample"></a>
Basic sample</h3>
<p>A simple execution chain. This code consists of three execution steps:</p><ul>
<li>first task generating a float, from another float given as argument</li>
<li>second task converting this float to string, a passing it to the next step</li>
<li>third step launch three <em>parallel</em> tasks. This doesn't mean neccesarily that that task will be executed in parallel, is just a hint so that the executor will do it in that way if it hast the capacity. To check for the kind of parallelism supported, a previous <a class="el" href="namespacemel_1_1execution.html#ac1c91ed37b04b6d4c85dfc6332187015">getExecutor</a> is inserted in order to inform the user. This step, in this concrete example, wouldn't be neccesary because we have the ExecutorType as function template parameter, but in a real example the job couldn't know anything about the underlying executor.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleBasic(ExecutorType ex)</div>
<div class="line">{   </div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget(</div>
<div class="line">            [ex]() <span class="keyword">mutable</span> {</div>
<div class="line">              <span class="keywordflow">try</span> {</div>
<div class="line">                <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">                    <a class="code" href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">mel::execution::launch</a>(</div>
<div class="line">                        ex, [](<span class="keywordtype">float</span> param) noexcept { <span class="keywordflow">return</span> param + 6.f; },</div>
<div class="line">                        10.5f) |</div>
<div class="line">                    <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>([](<span class="keywordtype">float</span> param) noexcept {</div>
<div class="line">                      <span class="keywordflow">return</span> std::to_string(param);</div>
<div class="line">                    }) |</div>
<div class="line">                    <a class="code" href="namespacemel_1_1execution.html#ac1c91ed37b04b6d4c85dfc6332187015">mel::execution::getExecutor</a>([](<span class="keyword">auto</span> ex,<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str) noexcept {</div>
<div class="line">                        <span class="keywordflow">if</span> constexpr(execution::ExecutorTraits&lt;decltype(ex)&gt;::has_parallelism)</div>
<div class="line">                            mel::text::info(<span class="stringliteral">&quot;Current executor supports true parallelism. Next job will be executed parallelized&quot;</span>);</div>
<div class="line">                        <span class="keywordflow">else</span></div>
<div class="line">                            mel::text::info(<span class="stringliteral">&quot;Current executor doesn&#39;t support true parallelism. Next job will be executed sequentially&quot;</span>);</div>
<div class="line">                        <span class="keywordflow">return</span> str;</div>
<div class="line">                    }) |</div>
<div class="line">                    <a class="code" href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a>(</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;str) noexcept{</div>
<div class="line">                          mel::text::info(<span class="stringliteral">&quot;Parallel 1. {}&quot;</span>, str + <span class="stringliteral">&quot; hello!&quot;</span>);</div>
<div class="line">                        },</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;str) noexcept{</div>
<div class="line">                          mel::text::info(<span class="stringliteral">&quot;Parallel 2. {}&quot;</span>, str + <span class="stringliteral">&quot; hi!&quot;</span>);</div>
<div class="line">                        },</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;str) noexcept{</div>
<div class="line">                          mel::text::info(<span class="stringliteral">&quot;Parallel 2. {}&quot;</span>, str + <span class="stringliteral">&quot; whats up!&quot;</span>);</div>
<div class="line">                        }));</div>
<div class="line">                <span class="keywordflow">if</span> (res.isValid()) {</div>
<div class="line">                  ::mel::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>, res.value());</div>
<div class="line">                }</div>
<div class="line">              } <span class="keywordflow">catch</span> (core::WaitException &amp;e) {</div>
<div class="line">                ::mel::text::error(<span class="stringliteral">&quot;Error while waiting: Reason={}&quot;</span>, e.what());</div>
<div class="line">              } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">                ::mel::text::error(<span class="stringliteral">&quot;Error while waiting: Unknown reason={}&quot;</span>);</div>
<div class="line">              }</div>
<div class="line">            },</div>
<div class="line">            0, <a class="code" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">::mel::tasking::Runnable::killFalse</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_runnable_html_a8321dac1a4a8f7415a5fdbcb5e540e62"><div class="ttname"><a href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">mel::tasking::Runnable::killFalse</a></div><div class="ttdeci">static std::function&lt; bool()&gt; killFalse</div><div class="ttdoc">helper function to reject kill when receiving kill signal</div><div class="ttdef"><b>Definition:</b> Runnable.h:276</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_ac1c91ed37b04b6d4c85dfc6332187015"><div class="ttname"><a href="namespacemel_1_1execution.html#ac1c91ed37b04b6d4c85dfc6332187015">mel::execution::getExecutor</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, std::invoke_result_t&lt; F, Executor&lt; ExecutorAgent &gt;, TArg &gt; &gt; getExecutor(ExFuture&lt; ExecutorAgent, TArg &gt; source, F f)</div><div class="ttdoc">Get the Executor used in the chain of execution.</div><div class="ttdef"><b>Definition:</b> Executor.h:553</div></div>
<div class="ttc" id="anamespacemel_1_1tasking_html_adcb60d6784a9c571ee675342fab73f7b"><div class="ttname"><a href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">mel::tasking::waitForFutureMThread</a></div><div class="ttdeci">::mel::core::WaitResult&lt; T &gt; waitForFutureMThread(const mel::core::Future&lt; T &gt; &amp;f, unsigned int msecs=EVENTMT_WAIT_INFINITE) noexcept(std::is_same&lt; ErrorType,::mel::core::WaitErrorNoException &gt;::value)</div><div class="ttdoc">Waits for future completion, returning a wapper around the internal vale.</div><div class="ttdef"><b>Definition:</b> utilities.h:94</div></div>
</div><!-- fragment --><p> Output will be: </p><pre class="fragment">Current executor supports true parallelism. Next job will be executed parallelized
Parallel 1. 16.500000 hello!
Parallel 2. 16.500000 hi!
Parallel 2. 16.500000 whats up!
Result value = 16.500000
</pre><p>Although the samples are shown using <em>lambdas</em> for clarity, any other callable can be used:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">float</span> f1(<span class="keywordtype">float</span> p1,<span class="keywordtype">float</span> p2) noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> p1+p2;</div>
<div class="line">        };</div>
<div class="line">        <span class="keywordtype">string</span> f2(<span class="keywordtype">float</span> p) noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> std::to_string(p);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str) noexcept</div>
<div class="line">        {</div>
<div class="line">            text::info(<span class="stringliteral">&quot;Parallel operator() {}&quot;</span>,str+<span class="stringliteral">&quot; hi!&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleCallables(ExecutorType ex)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    MyClass obj;</div>
<div class="line">     <span class="keyword">using namespace </span>std::placeholders;</div>
<div class="line">    th-&gt;fireAndForget([ex,&amp;obj] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">            execution::launch(ex,</div>
<div class="line">                std::bind(&amp;MyClass::f1,&amp;obj,6.7f,_1),10.5f)</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>(std::bind(&amp;MyClass::f2,&amp;obj,_1)) </div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a>( </div>
<div class="line">                MyClass(),</div>
<div class="line">                [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str)</div>
<div class="line">                {</div>
<div class="line">                    text::info(<span class="stringliteral">&quot;Parallel 2. {}&quot;</span>,str+<span class="stringliteral">&quot; hi!&quot;</span>);</div>
<div class="line">                },</div>
<div class="line">                [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str)</div>
<div class="line">                {</div>
<div class="line">                    text::info(<span class="stringliteral">&quot;Parallel 2. {}&quot;</span>,str+<span class="stringliteral">&quot; whats up!&quot;</span>);</div>
<div class="line">                }</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">        <span class="keywordflow">if</span> (res.isValid())</div>
<div class="line">        {</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
</div><!-- fragment --><p> And the output will be: </p><pre class="fragment">Parallel operator() 17.200001 hi!
Parallel 2. 17.200001 whats up!
Parallel 2. 17.200001 hi!
Result value = 17.200001
</pre><p> In the previous example we see some other callables: member functions, using bind and function object (with operator() ). </p><dl class="section warning"><dt>Warning</dt><dd>std::bind doesn't preserve <b>noexcept</b> specifier ( <a href="https://stackoverflow.com/questions/71673262/noexcept-preservation-using-bind">https://stackoverflow.com/questions/71673262/noexcept-preservation-using-bind</a>)- This is an important aspect to take into account as is explained in <a href="#error_management">this section</a> </dd></dl>
<h3><a class="anchor" id="using_references"></a>
Using references</h3>
<p>In this example, it's shown how to use references to variables. In order to be able to pass a reference to <a class="el" href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">launch</a> or to <a class="el" href="namespacemel_1_1execution.html#a26bfe70c6773c309cd8b411db27f115f">inmediate</a> we must use <a href="https://en.cppreference.com/w/cpp/utility/functional/ref">std::ref</a>, because it's not possible to deduce what the user wants only by the type of the parameter. Also, when a function wants to return a reference to the next function in the chain, it's neccesary to indicate it without auto deduction. So, if using a lambda as in the examples, you must specify the return type.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleReference(ExecutorType ex)</div>
<div class="line">{   </div>
<div class="line">    <span class="keywordtype">string</span> str = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex,&amp;str] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">            execution::launch(ex,[](<span class="keywordtype">string</span>&amp; str) noexcept -&gt;<span class="keywordtype">string</span>&amp;</div>
<div class="line">            {   </div>
<div class="line">                <span class="comment">//First job</span></div>
<div class="line">                str += <span class="stringliteral">&quot; Dani.&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            },std::ref(str))</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str) noexcept -&gt; <span class="keywordtype">string</span>&amp;</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Second job </span></div>
<div class="line">                str+= <span class="stringliteral">&quot; How are you?&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Third job</span></div>
<div class="line">                str += <span class="stringliteral">&quot;Bye!&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span> str ) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Fourth job</span></div>
<div class="line">                str += <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">        );</div>
<div class="line">        <span class="keywordflow">if</span> (res.isValid())</div>
<div class="line">        {</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Original str = {}&quot;</span>,str);</div>
<div class="line">        }</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
</div><!-- fragment --><p> And the output will be: </p><pre class="fragment">Result value = Hello Dani. How are you?Bye!See you!
Original str = Hello Dani. How are you?Bye!
</pre><p> As can be seen, the original string is modified, but only until third job. because this job doesn't return a reference to the next,that fourth job will receive a copy. Also just as a way to better understanding, the previous code is <b>functionally equivalent</b> to this other (redundant parts are removed): </p><div class="fragment"><div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">    execution::start(ex)</div>
<div class="line">    | <a class="code" href="namespacemel_1_1execution.html#a26bfe70c6773c309cd8b411db27f115f">mel::execution::inmediate</a>(std::ref(str))</div>
<div class="line">    | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>([](<span class="keywordtype">string</span>&amp; str) noexcept -&gt;<span class="keywordtype">string</span>&amp;</div>
<div class="line">    {   </div>
<div class="line">        <span class="comment">//First job</span></div>
<div class="line">        str += <span class="stringliteral">&quot; Dani.&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> str;</div>
<div class="line">    })</div>
<div class="line">    | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str) noexcept -&gt; <span class="keywordtype">string</span>&amp;</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Second job </span></div>
<div class="line">        str+= <span class="stringliteral">&quot; How are you?&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> str;</div>
<div class="line">    })</div>
<div class="line">    | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Third job</span></div>
<div class="line">        str += <span class="stringliteral">&quot;Bye!&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> str;</div>
<div class="line">    })</div>
<div class="line">    | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span> str ) noexcept</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Fourth job</span></div>
<div class="line">        str += <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> str;</div>
<div class="line">    })</div>
<div class="line">);</div>
<div class="line"><span class="keywordflow">if</span> (res.isValid())</div>
<div class="line">{</div>
<div class="line">    ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">    ::text::info(<span class="stringliteral">&quot;Original str = {}&quot;</span>,str);</div>
<div class="line">});</div>
<div class="ttc" id="anamespacemel_1_1execution_html_a26bfe70c6773c309cd8b411db27f115f"><div class="ttname"><a href="namespacemel_1_1execution.html#a26bfe70c6773c309cd8b411db27f115f">mel::execution::inmediate</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, typename std::remove_cv&lt; typename std::remove_reference&lt; TRet &gt;::type &gt;::type &gt; inmediate(ExFuture&lt; ExecutorAgent, TArg &gt; fut, TRet &amp;&amp;arg)</div><div class="ttdoc">Produces an inmediate value in the context of the given ExFuture executor as a response to input fut ...</div><div class="ttdef"><b>Definition:</b> Executor.h:89</div></div>
</div><!-- fragment --><p> Instead of launching a callable intially, the chain of execution is started with a <a class="el" href="namespacemel_1_1execution.html#a200611bdc3f3201ce07114f06347f3e0">start</a>, followed by a <a class="el" href="namespacemel_1_1execution.html#a26bfe70c6773c309cd8b411db27f115f">inmediate</a>. Although in this example this doesn't improves anything, can be usefull in other situations.</p>
<h3><a class="anchor" id="chaging_executor"></a>
Changing executor</h3>
<p>In this example we will show how to tranfer execution from one executor to another in the same flow. This is acomplished by the function <a class="el" href="namespacemel_1_1execution.html#a9c2d394e1f670743253c44823c2e26fc">transfer</a>. It's better seen with an example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Ex1, <span class="keyword">class</span> Ex2&gt; <span class="keywordtype">void</span> _sampleTransfer(Ex1 ex1,Ex2 ex2)</div>
<div class="line">{   </div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex1,ex2] () <span class="keyword">mutable</span></div>
<div class="line">    {       </div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line"> </div>
<div class="line">                execution::start(ex1)</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a26bfe70c6773c309cd8b411db27f115f">mel::execution::inmediate</a>(<span class="stringliteral">&quot;Hello &quot;</span>s)</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Second job </span></div>
<div class="line">                    text::info(<span class="stringliteral">&quot;NEXT: {}&quot;</span>,str);</div>
<div class="line">                    <span class="keywordflow">return</span> str + <span class="stringliteral">&quot;. How are you?&quot;</span>;</div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a9c2d394e1f670743253c44823c2e26fc">mel::execution::transfer</a>(ex2)</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#acbcaf139dc87026232b3816d7ecb256e">mel::execution::loop</a>(0,10, [](<span class="keywordtype">int</span> idx, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str) noexcept</div>
<div class="line">                {</div>
<div class="line">                    text::info(<span class="stringliteral">&quot;Iteration {}&quot;</span>, str + std::to_string(idx));</div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Fourth job. </span></div>
<div class="line">                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(core::WaitException&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Code= {}, Reason: {}&quot;</span>,(<span class="keywordtype">int</span>)e.getCode(),e.what());</div>
<div class="line">        }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Reason: {}&quot;</span>,e.what());</div>
<div class="line">        }</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemel_1_1execution_html_acbcaf139dc87026232b3816d7ecb256e"><div class="ttname"><a href="namespacemel_1_1execution.html#acbcaf139dc87026232b3816d7ecb256e">mel::execution::loop</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, TArg &gt; loop(ExFuture&lt; ExecutorAgent, TArg &gt; source, I &amp;&amp;begin, I &amp;&amp;end, F &amp;&amp;functor, int increment=1)</div><div class="ttdoc">parallel (possibly, depending on executor capabilities) loop</div><div class="ttdef"><b>Definition:</b> Executor.h:226</div></div>
</div><!-- fragment --><p> In this code the execution starts in the executor <code>ex1</code> and just before the loop, execution is transferred to the other (<code>ex2</code>). </p>
<h3><a class="anchor" id="converging_jobs"></a>
Converging several job flows</h3>
<p>Here an example on how to create several execution flows and merge their work. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType1,<span class="keyword">class</span> ExecutorType2&gt; <span class="keywordtype">void</span> _sampleSeveralFlows(ExecutorType1 ex1,ExecutorType2 ex2)</div>
<div class="line">{   </div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex1,ex2] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//First flow in one of the executors</span></div>
<div class="line">        <span class="keyword">auto</span> job1 = <a class="code" href="namespacemel_1_1execution.html#a200611bdc3f3201ce07114f06347f3e0">mel::execution::start</a>(ex1)</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(3000); <span class="comment">//only possible if the executor Has microthreading behaviour</span></div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;First job&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;First Job&quot;</span>;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Second job in the other executor</span></div>
<div class="line">        <span class="keyword">auto</span> job2 = <a class="code" href="namespacemel_1_1execution.html#a200611bdc3f3201ce07114f06347f3e0">mel::execution::start</a>(ex2)</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#aa452862b7a1d169e5a3be1e9fa1b66f2">mel::execution::parallel</a>( []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(300); <span class="comment">//only possible if the executor Has microthreading behaviour</span></div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;second job, t1&quot;</span>);</div>
<div class="line">        },</div>
<div class="line">        []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(100); <span class="comment">//only possible if the executor as microthreading behaviour</span></div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;second job, t2&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        )</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 10;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Third job in the same executor as before</span></div>
<div class="line">        <span class="keyword">auto</span> job3 = <a class="code" href="namespacemel_1_1execution.html#a200611bdc3f3201ce07114f06347f3e0">mel::execution::start</a>(ex2)</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#ac70c86e823891528b9f865c80853e6f1">mel::execution::parallel_convert</a>(</div>
<div class="line">         []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(300); <span class="comment">//only possible if the executor as microthreading behaviour</span></div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;third job, t1&quot;</span>);</div>
<div class="line">            <span class="comment">//don&#39;t return anything, so ignore this tuple element (but it exists with an empty type)   </span></div>
<div class="line">        },</div>
<div class="line">        []() noexcept</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(100); <span class="comment">//only possible if the executor as microthreading behaviour</span></div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;third job, t2&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 8.7f;</div>
<div class="line">        }</div>
<div class="line">        );</div>
<div class="line">       </div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//on_all need to be executed in a context of some excutor, so one of them is given</span></div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(execution::on_all(ex2,job1,job2,job3));</div>
<div class="line">            <span class="comment">//the result of the job merging is as a tuple, where each elements corresponds to the job in same position</span></div>
<div class="line">            <span class="keyword">auto</span>&amp; val = res.value();</div>
<div class="line">            ::mel::text::info(<span class="stringliteral">&quot;Result value = [{},{},(void,{})]&quot;</span>,</div>
<div class="line">                    std::get&lt;0&gt;(val),  <span class="comment">//first job result</span></div>
<div class="line">                    std::get&lt;1&gt;(val),   <span class="comment">//second job result</span></div>
<div class="line">                    std::get&lt;1&gt;(std::get&lt;2&gt;(val))  <span class="comment">//third job result</span></div>
<div class="line">            );</div>
<div class="line">            </div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(core::WaitException&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Code= {}, Reason: {}&quot;</span>,(<span class="keywordtype">int</span>)e.getCode(),e.what());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>( <a class="code" href="classmel_1_1execution_1_1_on_all_exception.html">mel::execution::OnAllException</a>&amp; e)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">try</span></div>
<div class="line">            {</div>
<div class="line">                rethrow_exception( e.getCause() );</div>
<div class="line">            }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">            {</div>
<div class="line">                mel::text::error(<span class="stringliteral">&quot;Error {}&quot;</span>,e.what());</div>
<div class="line">            }<span class="keywordflow">catch</span>(...)</div>
<div class="line">            {</div>
<div class="line">                mel::text::error(<span class="stringliteral">&quot;OnAllException. unknown error&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1execution_1_1_on_all_exception_html"><div class="ttname"><a href="classmel_1_1execution_1_1_on_all_exception.html">mel::execution::OnAllException</a></div><div class="ttdoc">Excepcion thrown by on_all when some of the futures raise error.</div><div class="ttdef"><b>Definition:</b> Executor.h:809</div></div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_html_ae3350d1645cca8cb94f65b1b85dff032"><div class="ttname"><a href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">mel::tasking::Process::wait</a></div><div class="ttdeci">static ESwitchResult wait(unsigned int msegs) OPTIMIZE_FLAGS</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_a200611bdc3f3201ce07114f06347f3e0"><div class="ttname"><a href="namespacemel_1_1execution.html#a200611bdc3f3201ce07114f06347f3e0">mel::execution::start</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, void &gt; start(Executor&lt; ExecutorAgent &gt; ex)</div><div class="ttdoc">Start a chain of execution in given executor.</div><div class="ttdef"><b>Definition:</b> Executor.h:80</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_ac70c86e823891528b9f865c80853e6f1"><div class="ttname"><a href="namespacemel_1_1execution.html#ac70c86e823891528b9f865c80853e6f1">mel::execution::parallel_convert</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, typename ::mel::execution::_private::GetReturn&lt; TArg, FTypes... &gt;::type &gt; parallel_convert(ExFuture&lt; ExecutorAgent, TArg &gt; source, FTypes... functions)</div><div class="ttdoc">Same as parallel but returning a tuple with the values for each functor.</div><div class="ttdef"><b>Definition:</b> Executor.h:508</div></div>
</div><!-- fragment --><p> And the output is: </p><pre class="fragment">{.cpp} 
second job, t2
third job, t2
second job, t1
third job, t1
First job
Result value = [First Job,10,(void,8.7)]
</pre><p> Again, only for educational purposes, some <em>microthread</em> waits were inserted in some of the tasks. The final result is the merge of the 3 jobs, <b>as a tuple</b>. Also, the third job returns a tuple (this is how <a class="el" href="namespacemel_1_1execution.html#ac70c86e823891528b9f865c80853e6f1">parallel_convert</a> works), and it's shown between parenthesis. </p>
<h3><a class="anchor" id="advance_example"></a>
Advanced example</h3>
<p>We are going to see a more real example with measurements to compare performance in various cases. Follow this <a class="el" href="execution_sample_advance.html">link</a> to explore it</p>
<h2><a class="anchor" id="error_management"></a>
Error management</h2>
<p>This is a very important part and need to be addressed carefully. When using any of the wait functions (<a class="el" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">mel::tasking::waitForFutureMThread</a> or <a class="el" href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a>) there are two possibilities for error detection according to template parameter <code>ErrorType</code>:</p><ul>
<li><em>throwing an exception</em> if any error occurs while executing that sequence of jobs the program is waiting for. This method is selected by using <a class="el" href="structmel_1_1core_1_1_wait_error_as_exception.html">WaitErrorAsException</a>. It's the default option when not specified <br  />
</li>
<li><em>no throwing an exception</em>. This is selected by using <a class="el" href="structmel_1_1core_1_1_wait_error_no_exception.html">WaitErrorNoException</a>. In this case the returned <a class="el" href="classmel_1_1execution_1_1_ex_future.html">mel::execution::ExFuture</a> from the execution chain must be checked for error (see <a class="el" href="classmel_1_1core_1_1_future___common.html#a663f1cf52f685b2a8e93e3d00f16ebf3">Future::getValue</a> and <a class="el" href="classmel_1_1core_1_1_future_value.html">mel::core::FutureValue</a>). Although the first option is more natural and more comfortable, this method will be used in cases when performance is critical or error is not need to be checked (maybe because user knows exactly that the code doesn't throw any exception).</li>
</ul>
<p>Let's see an example code:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleError1(ExecutorType ex)</div>
<div class="line">{   </div>
<div class="line">    <span class="keywordtype">string</span> str = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex,&amp;str] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">                <a class="code" href="namespacemel_1_1execution.html#aa15811b945ee6be8ccbfb93fdd66baa7">mel::execution::launch</a>(ex,[](<span class="keywordtype">string</span>&amp; str) noexcept -&gt;<span class="keywordtype">string</span>&amp;</div>
<div class="line">                {   </div>
<div class="line">                    <span class="comment">//First job</span></div>
<div class="line">                    str += <span class="stringliteral">&quot; Dani.&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                },std::ref(str))</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str) -&gt; <span class="keywordtype">string</span>&amp;</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Second job </span></div>
<div class="line">                    str+= <span class="stringliteral">&quot; How are you?&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;This is an error&quot;</span>);</div>
<div class="line">                    <span class="comment">//return str;</span></div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Third job. Will never be executed!!!</span></div>
<div class="line">                    str += <span class="stringliteral">&quot;Bye!&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span> str ) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Fourth job. Will never be executed</span></div>
<div class="line">                    str += <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(core::WaitException&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Code= {}, Reason: {}&quot;</span>,e.getCode(),e.what());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Reason: {}&quot;</span>,e.what());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(...)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Unknwon reason: {}&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        ::text::info(<span class="stringliteral">&quot;Original str = {}&quot;</span>,str);</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output will be: </p><pre class="fragment">[error] Some error occured!! Reason: This is an error
[info] Original str = Hello Dani. How are you?
</pre><p> In the previous code, and exception is thrown in the second job, so third and fourth jobs won't be executed. The wait is wrapped with a try/catch and the neccesary exceptions are checked. Things to take into account:</p><ul>
<li>If a job won't throw an exception (you have to be sure) you <em>shoud mark this function as <b>noexcept</b></em>. This way, the generated code will be more efficient (mainly in space).</li>
<li>Of course, yo can throw any type of object and follow the usual rules for exception management.</li>
<li>the <em>waitForFuture</em> functions will throw a <a class="el" href="classmel_1_1core_1_1_wait_exception.html">WaitException</a> if the wait was unsuccessful, as process killed, timeout,..</li>
</ul>
<p>But, what if we want to capture the error at some point and continue the chain of jobs? See next example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleError2(ExecutorType ex)</div>
<div class="line">{   </div>
<div class="line">    <span class="keywordtype">string</span> str = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex,&amp;str] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">::mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">                execution::launch(ex,[](<span class="keywordtype">string</span>&amp; str) noexcept -&gt;<span class="keywordtype">string</span>&amp;</div>
<div class="line">                {   </div>
<div class="line">                    <span class="comment">//First job</span></div>
<div class="line">                    str += <span class="stringliteral">&quot; Dani.&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                },std::ref(str))</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str) -&gt; <span class="keywordtype">string</span>&amp;</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Second job </span></div>
<div class="line">                    str+= <span class="stringliteral">&quot; How are you?&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;This is an error&quot;</span>);</div>
<div class="line">                    <span class="comment">//return str;</span></div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Third job. Will never be executed!!!</span></div>
<div class="line">                    str += <span class="stringliteral">&quot;Bye!&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a60515a3e4bce7adcf1b7ef51c850d3b7">mel::execution::catchError</a>( [](std::exception_ptr err)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error caught!! &quot;</span>;</div>
<div class="line">                })</div>
<div class="line">                | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span> str ) noexcept</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Fourth job. </span></div>
<div class="line">                    str += <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> str;</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(core::WaitException&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Code= {}, Reason: {}&quot;</span>,e.getCode(),e.what());</div>
<div class="line">        }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">        {</div>
<div class="line">            ::text::error(<span class="stringliteral">&quot;Some error occured!! Reason: {}&quot;</span>,e.what());</div>
<div class="line">        }</div>
<div class="line">        ::text::info(<span class="stringliteral">&quot;Original str = {}&quot;</span>,str);</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemel_1_1execution_html_a60515a3e4bce7adcf1b7ef51c850d3b7"><div class="ttname"><a href="namespacemel_1_1execution.html#a60515a3e4bce7adcf1b7ef51c850d3b7">mel::execution::catchError</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, TArg &gt; catchError(ExFuture&lt; ExecutorAgent, TArg &gt; source, F &amp;&amp;f)</div><div class="ttdoc">Capture previous error, if any, and execute the function.</div><div class="ttdef"><b>Definition:</b> Executor.h:415</div></div>
</div><!-- fragment --><p> And the output will be: </p><pre class="fragment">{.cpp} 
[info] Result value = Error caught!! See you!
[info] Original str = Hello Dani. How are you?
</pre><p> Because the error was captured in the job chain, no exception was thrown. The <a class="el" href="namespacemel_1_1execution.html#a60515a3e4bce7adcf1b7ef51c850d3b7">catchError</a> function gets an exception as parameter and <em>must return the same type</em> as the previous job in the chain (because this type is what that job expects . If no exception was launched <em>before</em> the catchError call, this function will be ignored.</p>
<p>And, just for comparison, the same first example disabling exceptions in the wait: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _sampleErrorNoException(ExecutorType ex)</div>
<div class="line">{   </div>
<div class="line">    <span class="keywordtype">string</span> str = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">    th-&gt;fireAndForget([ex,&amp;str] () <span class="keyword">mutable</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> res = ::mel::tasking::waitForFutureMThread&lt;::mel::core::WaitErrorNoException&gt;(</div>
<div class="line">            execution::launch(ex,[](<span class="keywordtype">string</span>&amp; str) noexcept -&gt;<span class="keywordtype">string</span>&amp;</div>
<div class="line">            {   </div>
<div class="line">                <span class="comment">//First job</span></div>
<div class="line">                str += <span class="stringliteral">&quot; Dani.&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            },std::ref(str))</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str) -&gt; <span class="keywordtype">string</span>&amp;</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Second job </span></div>
<div class="line">                str+= <span class="stringliteral">&quot; How are you?&quot;</span>;</div>
<div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;This is an error&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span>&amp; str ) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Third job. Will never be executed!!!</span></div>
<div class="line">                str += <span class="stringliteral">&quot;Bye!&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">            | <a class="code" href="namespacemel_1_1execution.html#a460fabb63e024b68842b3f2575373439">mel::execution::next</a>( [](<span class="keywordtype">string</span> str ) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//Fourth job. </span></div>
<div class="line">                str += <span class="stringliteral">&quot;See you!&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> str;</div>
<div class="line">            })</div>
<div class="line">        );</div>
<div class="line">        <span class="comment">//need to check if some error occurred</span></div>
<div class="line">        <span class="keywordflow">if</span> (res.isValid())</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,res.value());</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {  </div>
<div class="line">            <span class="comment">//error branch.</span></div>
<div class="line">            <span class="keywordflow">try</span></div>
<div class="line">            {</div>
<div class="line">                std::rethrow_exception(res.error());</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span>(core::WaitException&amp; e)</div>
<div class="line">            {</div>
<div class="line">                ::text::error(<span class="stringliteral">&quot;Some error occured!! Code= {}, Reason: {}&quot;</span>,(<span class="keywordtype">int</span>)e.getCode(),e.what());</div>
<div class="line">            }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">            {</div>
<div class="line">                ::text::error(<span class="stringliteral">&quot;Some error occured!! Reason: {}&quot;</span>,e.what());</div>
<div class="line">            }</div>
<div class="line">            ::text::info(<span class="stringliteral">&quot;Original str = {}&quot;</span>,str);</div>
<div class="line">        }</div>
<div class="line">    },0,::tasking::Runnable::killFalse);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="perfect_forwarding"></a>
Perfect forwarding</h2>
<p>Perefect-forwarding is tried to be achieved in every argument agument passing between jobs, so avoiding copies as much as possible. The best way to see that is by showing an example. First, we will have a class <code>TestClass</code> which will log whenever a constructor/assignment is done. This is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>SampleClass</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> val;</div>
<div class="line">    <span class="keyword">explicit</span> SampleClass(<span class="keywordtype">float</span> v = 0.0):val(v)</div>
<div class="line">    {</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass constructor&quot;</span>);</div>
<div class="line">    }   </div>
<div class="line">    SampleClass(<span class="keyword">const</span> SampleClass&amp; ob)</div>
<div class="line">    {</div>
<div class="line">        val = ob.val;</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass copy constructor&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    SampleClass(SampleClass&amp;&amp; ob)</div>
<div class="line">    {</div>
<div class="line">        val = ob.val;</div>
<div class="line">        ob.val = -1;</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass move constructor&quot;</span>);      </div>
<div class="line">    }</div>
<div class="line">    ~SampleClass()</div>
<div class="line">    {</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass destructor&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    SampleClass&amp; operator=(<span class="keyword">const</span> SampleClass&amp; ob)</div>
<div class="line">    {</div>
<div class="line">        val = ob.val;</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass copy operator=&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    SampleClass&amp; operator=(SampleClass&amp;&amp; ob)</div>
<div class="line">    {</div>
<div class="line">        val = ob.val;</div>
<div class="line">        ob.val = -1;</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;SampleClass move operator=&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The code will be: </p><div class="fragment"><div class="line">SampleClass cl(5);</div>
<div class="line"><span class="keyword">auto</span> th = ThreadRunnable::create();</div>
<div class="line">th-&gt;fireAndForget(</div>
<div class="line">    [ex,&amp;cl]() <span class="keyword">mutable</span> </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> ref = <a class="code" href="namespacemel_1_1tasking.html#adcb60d6784a9c571ee675342fab73f7b">mel::tasking::waitForFutureMThread</a>(</div>
<div class="line">                execution::launch(ex, [](SampleClass&amp; input) -&gt; SampleClass&amp;</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Job 1</span></div>
<div class="line">                    input.val++;</div>
<div class="line">                    <span class="keywordflow">return</span> input;  <span class="comment">//return reference to input argument</span></div>
<div class="line">                },std::ref(cl))</div>
<div class="line">                | execution::next( [](SampleClass&amp; input)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Job 2</span></div>
<div class="line">                    input.val++;</div>
<div class="line">                    <span class="keywordflow">return</span> input; <span class="comment">//returns a copy, because return type is not specified in lambda</span></div>
<div class="line">                } )</div>
<div class="line">                | execution::next( [](SampleClass&amp; input)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//Job 3</span></div>
<div class="line">                    <span class="keyword">auto</span> ret = input;</div>
<div class="line">                    ret.val++;</div>
<div class="line">                    <span class="keywordflow">return</span> ret; </div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Result value = {}&quot;</span>,ref.value().val);</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Original value = {}&quot;</span>,cl.val);</div>
<div class="line">        }<span class="keywordflow">catch</span>(...)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//...</span></div>
<div class="line">            mel::text::error(<span class="stringliteral">&quot;_samplePF unknown error!!!&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    },0,::tasking::Runnable::killFalse</div>
<div class="line">);</div>
</div><!-- fragment --><p> And now the out, in which comments are added to explain where every concrete message comes from:</p>
<pre class="fragment">SampleClass constructor         -&gt; contruction of object 'cl'
SampleClass copy constructor    -&gt; copy construction as result in Job 2
SampleClass move constructor    -&gt; moved to the new Job 3
SampleClass destructor          -&gt; destroyed object returned in Job 2
SampleClass copy constructor    -&gt; creation of `ret`in Job3
SampleClass move constructor    -&gt; return from Job3
SampleClass destructor
SampleClass move constructor    -&gt;move to final result
SampleClass destructor
SampleClass destructor
Result value = 7
Original value = 7
SampleClass destructor
SampleClass destructor
</pre><p>As can be seen, perfect forwarding is trying to be applied when possible. One thing to keep in maind is that, because every job implies launching a task to target executor, move constructions are impossible to avoid. This is because the asynchronous nature of the system.</p>
<h2><a class="anchor" id="work_flows"></a>
Work flows</h2>
<p>It's possible to create independent work flows to reuse them or apply them at functions as condition. Follow the <a class="el" href="execution_flows.html">link</a> for a more in deep explanation, </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Introduction</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
