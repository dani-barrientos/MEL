<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: mel::execution Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemel.html">mel</a></li><li class="navelem"><a class="el" href="namespacemel_1_1execution.html">execution</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mel::execution Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>High level execution utilities.  
<a href="namespacemel_1_1execution.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1execution_1_1_executor_3_01_runnable_01_4.html">Executor&lt; Runnable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a> specialization using Runnable as execution agent.  <a href="classmel_1_1execution_1_1_executor_3_01_runnable_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1execution_1_1_executor_3_01_thread_pool_01_4.html">Executor&lt; ThreadPool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a> specialization using a ThreadPool as execution agent.  <a href="classmel_1_1execution_1_1_executor_3_01_thread_pool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmel_1_1execution_1_1_executor_traits.html">ExecutorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmel_1_1execution_1_1_executor_traits_3_01_runnable_01_4.html">ExecutorTraits&lt; Runnable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a> Traits for Runnable <a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>.  <a href="structmel_1_1execution_1_1_executor_traits_3_01_runnable_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmel_1_1execution_1_1_executor_traits_3_01_thread_pool_01_4.html">ExecutorTraits&lt; ThreadPool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a> Traits for ThreadPool <a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>.  <a href="structmel_1_1execution_1_1_executor_traits_3_01_thread_pool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of <a class="el" href="classmel_1_1core_1_1_future.html">mel::core::Future</a> to apply to executors.  <a href="classmel_1_1execution_1_1_ex_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmel_1_1execution_1_1_on_all_exception.html">OnAllException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excepcion thrown by <a class="el" href="namespacemel_1_1execution.html#a789d1502a968251fcc5ac40bdb4724b7">on_all</a> when some of the futures raise error.  <a href="classmel_1_1execution_1_1_on_all_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmel_1_1execution_1_1_runnable_executor_opts.html">RunnableExecutorOpts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete options for this type of executor.  <a href="structmel_1_1execution_1_1_runnable_executor_opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmel_1_1execution_1_1_thread_pool_executor_opts.html">ThreadPoolExecutorOpts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete options for this type of executor.  <a href="structmel_1_1execution_1_1_thread_pool_executor_opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c008697e5e12a69ade00e0fd0ae3254"><td class="memItemLeft" align="right" valign="top"><a id="a0c008697e5e12a69ade00e0fd0ae3254" name="a0c008697e5e12a69ade00e0fd0ae3254"></a>
typedef <a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; <a class="el" href="classmel_1_1tasking_1_1_runnable.html">Runnable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RunnableExecutor</b></td></tr>
<tr class="separator:a0c008697e5e12a69ade00e0fd0ae3254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0ddd0955796bd634b11035be2161d7"><td class="memItemLeft" align="right" valign="top"><a id="a5e0ddd0955796bd634b11035be2161d7" name="a5e0ddd0955796bd634b11035be2161d7"></a>
typedef <a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ThreadPool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPoolExecutor</b></td></tr>
<tr class="separator:a5e0ddd0955796bd634b11035be2161d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b8fe6a77c3deadbe6fbe0af5d77f997"><td class="memTemplParams" colspan="2">template&lt;class F , class ExecutorAgent &gt; </td></tr>
<tr class="memitem:a2b8fe6a77c3deadbe6fbe0af5d77f997"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a2b8fe6a77c3deadbe6fbe0af5d77f997">launch</a> (<a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt; ex, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a2b8fe6a77c3deadbe6fbe0af5d77f997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch given functor in given executor.  <a href="namespacemel_1_1execution.html#a2b8fe6a77c3deadbe6fbe0af5d77f997">More...</a><br /></td></tr>
<tr class="separator:a2b8fe6a77c3deadbe6fbe0af5d77f997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b41251946ebb184a4ae8290a6b6eb67"><td class="memTemplParams" colspan="2">template&lt;class TArg , class F , class ExecutorAgent &gt; </td></tr>
<tr class="memitem:a1b41251946ebb184a4ae8290a6b6eb67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a1b41251946ebb184a4ae8290a6b6eb67">launch</a> (<a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt; ex, F &amp;&amp;f, TArg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a1b41251946ebb184a4ae8290a6b6eb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch given functor in given executor, passing it input parameter.  <a href="namespacemel_1_1execution.html#a1b41251946ebb184a4ae8290a6b6eb67">More...</a><br /></td></tr>
<tr class="separator:a1b41251946ebb184a4ae8290a6b6eb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662b395c769358f1f16b35e240f95000"><td class="memTemplParams" colspan="2">template&lt;class ExecutorAgent &gt; </td></tr>
<tr class="memitem:a662b395c769358f1f16b35e240f95000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a662b395c769358f1f16b35e240f95000">start</a> (<a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt; ex)</td></tr>
<tr class="memdesc:a662b395c769358f1f16b35e240f95000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a chain of execution in given executor. <br  />
  <a href="namespacemel_1_1execution.html#a662b395c769358f1f16b35e240f95000">More...</a><br /></td></tr>
<tr class="separator:a662b395c769358f1f16b35e240f95000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac057c88aafe847aa78f2fbea5e15cbc9"><td class="memTemplParams" colspan="2"><a id="ac057c88aafe847aa78f2fbea5e15cbc9" name="ac057c88aafe847aa78f2fbea5e15cbc9"></a>
template&lt;class ExecutorAgent , class TArg , class TRet &gt; </td></tr>
<tr class="memitem:ac057c88aafe847aa78f2fbea5e15cbc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, typename std::remove_cv&lt; typename std::remove_reference&lt; TRet &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inmediate</b> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; fut, TRet &amp;&amp;arg)</td></tr>
<tr class="memdesc:ac057c88aafe847aa78f2fbea5e15cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces an inmediate value in the context of the given <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> executor as a response to input fut completion If input fut has error, the this error is forwarded to inmediate result. <br /></td></tr>
<tr class="separator:ac057c88aafe847aa78f2fbea5e15cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6ef20f66ea3c8224713358433cb7f"><td class="memTemplParams" colspan="2">template&lt;class F , class TArg , class ExecutorAgent &gt; </td></tr>
<tr class="memitem:acbd6ef20f66ea3c8224713358433cb7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#acbd6ef20f66ea3c8224713358433cb7f">next</a> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; source, F &amp;&amp;f)</td></tr>
<tr class="memdesc:acbd6ef20f66ea3c8224713358433cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a functor to execute when input fut is complete Given functor will be executed inf the input <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> executor. input parameter is always pass as reference.  <a href="namespacemel_1_1execution.html#acbd6ef20f66ea3c8224713358433cb7f">More...</a><br /></td></tr>
<tr class="separator:acbd6ef20f66ea3c8224713358433cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bdcba7dfd8bd00c4c43418bfb7de6a"><td class="memTemplParams" colspan="2"><a id="a80bdcba7dfd8bd00c4c43418bfb7de6a" name="a80bdcba7dfd8bd00c4c43418bfb7de6a"></a>
template&lt;class NewExecutorAgent , class OldExecutorAgent , class TRet &gt; </td></tr>
<tr class="memitem:a80bdcba7dfd8bd00c4c43418bfb7de6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; NewExecutorAgent, TRet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transfer</b> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; OldExecutorAgent, TRet &gt; fut, <a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; NewExecutorAgent &gt; newAgent)</td></tr>
<tr class="memdesc:a80bdcba7dfd8bd00c4c43418bfb7de6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer given <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> to a different executor This way, continuations can be chained but executed in diferent executors. <br /></td></tr>
<tr class="separator:a80bdcba7dfd8bd00c4c43418bfb7de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deb777d97f781cf7b8421d458ffd931"><td class="memTemplParams" colspan="2">template&lt;class ExecutorAgent , class TArg , class I , class F &gt; </td></tr>
<tr class="memitem:a5deb777d97f781cf7b8421d458ffd931"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a5deb777d97f781cf7b8421d458ffd931">loop</a> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; source, I &amp;&amp;begin, I &amp;&amp;end, F &amp;&amp;functor, int increment=1)</td></tr>
<tr class="memdesc:a5deb777d97f781cf7b8421d458ffd931"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel (possibly, depending on executor capabilities) loop  <a href="namespacemel_1_1execution.html#a5deb777d97f781cf7b8421d458ffd931">More...</a><br /></td></tr>
<tr class="separator:a5deb777d97f781cf7b8421d458ffd931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afa7fbbfbe53479f3eab36cd70e62ba"><td class="memTemplParams" colspan="2">template&lt;class ExecutorAgent , class TArg , class ... FTypes&gt; </td></tr>
<tr class="memitem:a4afa7fbbfbe53479f3eab36cd70e62ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a4afa7fbbfbe53479f3eab36cd70e62ba">parallel</a> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; source, FTypes &amp;&amp;... functions)</td></tr>
<tr class="memdesc:a4afa7fbbfbe53479f3eab36cd70e62ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute given functions in a (possibly, depending on concrete executor) parallel way If an exception is thrown in any of the callables, and noexcept is no specified, the value of the first exception thrown is set as error in the resulting future, so forwarding the error to the next element (if any) of the chain.  <a href="namespacemel_1_1execution.html#a4afa7fbbfbe53479f3eab36cd70e62ba">More...</a><br /></td></tr>
<tr class="separator:a4afa7fbbfbe53479f3eab36cd70e62ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac984afe16072e046acc7a8af8878b049"><td class="memTemplParams" colspan="2"><a id="ac984afe16072e046acc7a8af8878b049" name="ac984afe16072e046acc7a8af8878b049"></a>
template&lt;class F , class TArg , class ExecutorAgent &gt; </td></tr>
<tr class="memitem:ac984afe16072e046acc7a8af8878b049"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>catchError</b> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; source, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ac984afe16072e046acc7a8af8878b049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture previous error, if any, and execute the function this function works similar to next, but receiving an std::exception_ptr as the parameter and must return same type as input future is no error was raised in previous works of the chain, the functions is not executed. <br /></td></tr>
<tr class="separator:ac984afe16072e046acc7a8af8878b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b78eac8859309de5367c51a1db6ba9"><td class="memTemplParams" colspan="2"><a id="a68b78eac8859309de5367c51a1db6ba9" name="a68b78eac8859309de5367c51a1db6ba9"></a>
template&lt;class ResultTuple , class ExecutorAgent , class TArg , class ... FTypes&gt; </td></tr>
<tr class="memitem:a68b78eac8859309de5367c51a1db6ba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, ResultTuple &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_convert</b> (<a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; source, FTypes &amp;&amp;... functions)</td></tr>
<tr class="memdesc:a68b78eac8859309de5367c51a1db6ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="namespacemel_1_1execution.html#a4afa7fbbfbe53479f3eab36cd70e62ba">parallel</a> but returning a tuple with the values for each functor So, these functors must return a value, return void is not allowed. <br /></td></tr>
<tr class="separator:a68b78eac8859309de5367c51a1db6ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e85e887b63e7541e16123e1cf7cc8f"><td class="memTemplParams" colspan="2"><a id="af4e85e887b63e7541e16123e1cf7cc8f" name="af4e85e887b63e7541e16123e1cf7cc8f"></a>
template&lt;class ExecutorAgent , class TRet1 , class U &gt; </td></tr>
<tr class="memitem:af4e85e887b63e7541e16123e1cf7cc8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TRet1 &gt; &amp;input, U &amp;&amp;u)</td></tr>
<tr class="memdesc:af4e85e887b63e7541e16123e1cf7cc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload operator | for chaining <br /></td></tr>
<tr class="separator:af4e85e887b63e7541e16123e1cf7cc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789d1502a968251fcc5ac40bdb4724b7"><td class="memTemplParams" colspan="2">template&lt;class ExecutorAgent , class ... FTypes&gt; </td></tr>
<tr class="memitem:a789d1502a968251fcc5ac40bdb4724b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemel_1_1execution.html#a789d1502a968251fcc5ac40bdb4724b7">on_all</a> (<a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt; ex, FTypes... futs)</td></tr>
<tr class="memdesc:a789d1502a968251fcc5ac40bdb4724b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> which will be executed, in the context of the given executor ex, when all the given ExFutures are triggered. The resulting <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> has a std::tuple with the types if the given ExFutures in the same order. So, all of them must return a value, void is not allowed If any of the given input <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> has error, the returned one will have the same error indicating the element who failed  <a href="namespacemel_1_1execution.html#a789d1502a968251fcc5ac40bdb4724b7">More...</a><br /></td></tr>
<tr class="separator:a789d1502a968251fcc5ac40bdb4724b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >High level execution utilities. </p>
<p >This namespace contains class, functions..to give a consistent execution interface independent of the underliying execution system See <a class="el" href="execution_system.html">Execution System</a> for detailed explanations and examples </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2b8fe6a77c3deadbe6fbe0af5d77f997" name="a2b8fe6a77c3deadbe6fbe0af5d77f997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8fe6a77c3deadbe6fbe0af5d77f997">&#9670;&nbsp;</a></span>launch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class ExecutorAgent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F &gt; &gt; mel::execution::launch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch given functor in given executor. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> with return type of function </dd></dl>

</div>
</div>
<a id="a1b41251946ebb184a4ae8290a6b6eb67" name="a1b41251946ebb184a4ae8290a6b6eb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b41251946ebb184a4ae8290a6b6eb67">&#9670;&nbsp;</a></span>launch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TArg , class F , class ExecutorAgent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &gt; &gt; mel::execution::launch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch given functor in given executor, passing it input parameter. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> with return type of function </dd></dl>

</div>
</div>
<a id="a5deb777d97f781cf7b8421d458ffd931" name="a5deb777d97f781cf7b8421d458ffd931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deb777d97f781cf7b8421d458ffd931">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutorAgent , class TArg , class I , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; mel::execution::loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>increment</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parallel (possibly, depending on executor capabilities) loop </p>
<dl class="section note"><dt>Note</dt><dd>concrete executor must provide a member loop function with neccesary interface </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> with same value as input future, whose content IS MOVED </dd></dl>

</div>
</div>
<a id="acbd6ef20f66ea3c8224713358433cb7f" name="acbd6ef20f66ea3c8224713358433cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd6ef20f66ea3c8224713358433cb7f">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class TArg , class ExecutorAgent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &amp; &gt; &gt; mel::execution::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a functor to execute when input fut is complete Given functor will be executed inf the input <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> executor. input parameter is always pass as reference. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> with type given by functor result. </dd></dl>

</div>
</div>
<a id="a789d1502a968251fcc5ac40bdb4724b7" name="a789d1502a968251fcc5ac40bdb4724b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789d1502a968251fcc5ac40bdb4724b7">&#9670;&nbsp;</a></span>on_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutorAgent , class ... FTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mel::execution::on_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FTypes...&#160;</td>
          <td class="paramname"><em>futs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> which will be executed, in the context of the given executor ex, when all the given ExFutures are triggered. The resulting <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> has a std::tuple with the types if the given ExFutures in the same order. So, all of them must return a value, void is not allowed If any of the given input <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> has error, the returned one will have the same error indicating the element who failed </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmel_1_1execution_1_1_on_all_exception.html" title="Excepcion thrown by on_all when some of the futures raise error.">OnAllException</a></td><td>if any error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4afa7fbbfbe53479f3eab36cd70e62ba" name="a4afa7fbbfbe53479f3eab36cd70e62ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afa7fbbfbe53479f3eab36cd70e62ba">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutorAgent , class TArg , class ... FTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt; mel::execution::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, TArg &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>functions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute given functions in a (possibly, depending on concrete executor) parallel way If an exception is thrown in any of the callables, and noexcept is no specified, the value of the first exception thrown is set as error in the resulting future, so forwarding the error to the next element (if any) of the chain. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmel_1_1execution_1_1_ex_future.html" title="Extension of mel::core::Future to apply to executors.">ExFuture</a> with same value as input future, whose content IS MOVED </dd></dl>

</div>
</div>
<a id="a662b395c769358f1f16b35e240f95000" name="a662b395c769358f1f16b35e240f95000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662b395c769358f1f16b35e240f95000">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExecutorAgent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmel_1_1execution_1_1_ex_future.html">ExFuture</a>&lt; ExecutorAgent, void &gt; mel::execution::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmel_1_1execution_1_1_executor.html">Executor</a>&lt; ExecutorAgent &gt;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a chain of execution in given executor. <br  />
 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutorAgent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ExFuture&lt;ExecutorAgent,void&gt; </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
