<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: Tasking System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tasking System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Contents of this section:</p><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#posting_tasks">Posting tasks</a></li>
<li><a href="#microthreading">Microthreading</a></li>
<li><a href="#terminating_tasks">Terminating tasks</a></li>
<li><a href="#custom_tasks">Custom tasks</a></li>
<li><a href="#runnable_specialization">Runnable specialization</a></li>
<li><a href="#sync_macros">Synchronization macros</a></li>
<li><a href="#limitations">Known limitations</a></li>
</ul>
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>As it was said in the <a class="el" href="index.html">main page</a>, the core pieces of the tasking system are: </p><ul>
<li>
<a class="el" href="classmel_1_1tasking_1_1_process.html">mel::tasking::Process</a> : Represents a task with <em>microthread</em> capabilities. We will explain this capabilities later in the text  </li>
<li>
<a class="el" href="classmel_1_1tasking_1_1_process_scheduler.html">mel::tasking::ProcessScheduler</a> : Simple scheduler executing processes sequentially. It's designed for performance in mnind, so no priority considerations, and only execute processes and evict them when finished. The idea is posting new tasks to be as fast as possible.  </li>
<li>
<a class="el" href="classmel_1_1tasking_1_1_runnable.html">mel::tasking::Runnable</a> : Base class serving as interface between final user a the internal ProcessScheduler it has.  </li>
<li>
<a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">mel::tasking::ThreadRunnable</a> : A Thread with <a class="el" href="classmel_1_1tasking_1_1_runnable.html">Runnable</a> behaviour. This will be the most common tool to spread new threads and work with tasks.  </li>
</ul>
<p>Here a very simple class diagram showing their relationships. </p><div class="image">
<img src="tasking.jpg" alt=""/>
</div>
 <h2><a class="anchor" id="posting_tasks"></a>
Posting tasks to runnables</h2>
<p><a class="el" href="classmel_1_1tasking_1_1_runnable.html">Runnables</a> are only a wrapper around <a class="el" href="classmel_1_1tasking_1_1_process_scheduler.html">ProcessScheduler</a> to facilitate tasks management. A Runnable usually consists only in executing the tasks in the internal scheduler in an infinite loop. Usually it's enough to use a <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html">ThreadRunnable</a>, which is an specialization executing the tasks in a thread.</p>
<p>Now, better let's shown an example and explain the different parts: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleTasking1()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; killPolicy = Runnable::killTrue;</div>
<div class="line">    th1-&gt;post([](uint64_t msecs,Process* p)</div>
<div class="line">        {</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;execute task. Time={}&quot;</span>,msecs);</div>
<div class="line">            return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">        },killPolicy,period);</div>
<div class="line">    <a class="code" href="classmel_1_1core_1_1_thread.html#ac4a0c4c1899348c015c92a265759c68d">::mel::core::Thread::sleep</a>(5000);</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1core_1_1_thread_html_ac4a0c4c1899348c015c92a265759c68d"><div class="ttname"><a href="classmel_1_1core_1_1_thread.html#ac4a0c4c1899348c015c92a265759c68d">mel::core::Thread::sleep</a></div><div class="ttdeci">static void sleep(const unsigned int millis)</div></div>
</div><!-- fragment --><p> The result of the code is, simply, to execute a task given by the lambda (any callable can be used for posting tasks. Lambdas are used throughout the documentation for simplicity) every 450 msecs during 5000 msecs. Now let's explain the important parts:</p><ul>
<li>A task always receive the scheduler time (<em>msecs</em> parameter) and the process which is executing the function. Keep in mind that this post method is only a helper for posting tasks. The very basic method is, really, <a class="el" href="classmel_1_1tasking_1_1_runnable.html#a775fa406358dc7b798116ab68473c037">mel::tasking::Runnable::postTask</a>. but this need user to create you own process and implementing the neccesary interface.</li>
<li><a class="anchor" id="kill_situations"></a>A task will finish in two situations:<ul>
<li>returning <a class="el" href="namespacemel_1_1tasking.html#a96d9377d27d919302df6839559a34a5da3986dd0914958ae2115e0ae7f10beef3" title="Kill the process.">mel::tasking::EGenericProcessResult::KILL</a></li>
<li>calling <a class="el" href="classmel_1_1tasking_1_1_process.html#a66583b3f1222e69ec9af4c142525fac8">mel::tasking::Process::kill</a> on the process. A ThreadRunnable, when destroyed, will try to kill all its processes, and waits until all process are finished. If a posted task use de <em>killPolicy</em> <a class="el" href="classmel_1_1tasking_1_1_runnable.html#aa13d5da09bbc07193a5b3a4992165f3d">killTrue</a>, it will be automatically killed when it receives a kill request. In case of using <a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a> the kill will always be rejected. Really, the <em>killPolicy</em> argument is a callable which will be evaluated when the process receives a kill signal, so allowing to acept or reject the kill according to other things; <em>killTrue</em> and <em>killFalse</em> are only helpers for these common behaviours.</li>
</ul>
</li>
</ul>
<p>If we had removed the line with the <em>sleep</em> at the end of the function, <em>th1</em> would be destroyed inmediately after the <em>post</em>, and so, the posted task would be killed inmediately.</p>
<p>If we had have the next code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line"><span class="keyword">auto</span>&amp; killPolicy = Runnable::killFalse;</div>
<div class="line">th1-&gt;post([](uint64_t msecs,Process* p)</div>
<div class="line">    {</div>
<div class="line">        mel::text::info( <span class="stringliteral">&quot;execute task. Time={}&quot;</span>,msecs);</div>
<div class="line">        return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">    },killPolicy,period);</div>
</div><!-- fragment --><p> In this case the function will never end: <em>th1</em> will be waiting for its taks (only one task in this case!) sending them a kill request. But, because that task is using <em>Runnable::killFalse</em> it will always reject this kill request. Also, the <em>posted</em> task could be taken and killed directly: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line"><span class="keyword">auto</span>&amp; killPolicy = Runnable::killFalse;</div>
<div class="line">std::shared_ptr&lt;mel::tasking::Process&gt; task = th1-&gt;post([](uint64_t msecs,Process* p)</div>
<div class="line">    {</div>
<div class="line">        mel::text::info( <span class="stringliteral">&quot;execute task. Time={}&quot;</span>,msecs);</div>
<div class="line">        return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">    },killPolicy,period);</div>
<div class="line">task-&gt;kill(<span class="keyword">true</span>); <span class="comment">//the *true* parameter force killing of the task, ignoring the *killPolicy*</span></div>
</div><!-- fragment --><p> A very common case is posting task that only need to be executed <em>once</em>, so the interface could be simplified. Thsi is accompmplished by fireAndForget. In this case the task iput parameters are removed and the function automatically returns <a class="el" href="namespacemel_1_1tasking.html#a96d9377d27d919302df6839559a34a5da3986dd0914958ae2115e0ae7f10beef3" title="Kill the process.">mel::tasking::EGenericProcessResult::KILL</a> </p><div class="fragment"><div class="line">th1-&gt;fireAndForget( []()</div>
<div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> startTime = 50; <span class="comment">//the task will be executed 50 mecs being posted</span></div>
<div class="line">    th1-&gt;fireAndForget( []()</div>
<div class="line">    {</div>
<div class="line">        mel::text::info( <span class="stringliteral">&quot;Done!&quot;</span>);</div>
<div class="line">    },startTime,Runnable::killFalse);</div>
</div><!-- fragment --><h2><a class="anchor" id="microthreading"></a>
Microthreading</h2>
<p>A <em>microthread</em>, implemented in class <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a>, is a task that can be interrupted at any point and, when resumed, continue executing from that point. This allows to be able to execute a huge number of tasks with <em>cooperative multitasking</em> with very litlle penalty. If a task doesn't make any context switch, the penalty is almost 0. The cost only occurs when a context switch is done and when recovering later. Actually is very little cost, but of course it exists. The functions which control context switches are: <a class="el" href="classmel_1_1tasking_1_1_process.html#a31bcb7b51959dabec561a1ed4b3de4d7">switchProcess</a>, <a class="el" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">wait</a> and <a class="el" href="classmel_1_1tasking_1_1_process.html#a7d9fbde408b9e7b6a5dafa671a4048fd">sleep</a> (and its counterpart <a class="el" href="classmel_1_1tasking_1_1_process.html#a0e9ead0504f6ebf9ae784ea39128536f">wakeUp</a>). Those functions are <em>static</em>. This means that calling any of they, the <em>current process</em> (in the current threads) is affected. This is exactly the same as with threads: you call a "sleep", event waits... inside the current thread, but no passing them a thread as a parameter. The exception, as is natural, is the function <em>wakeUp</em> which need to know what process to wakeup.</p>
<p>In the next code, two tasks are executing code in an interleaved way, showing an example of cooperative multitasking.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleTasking2()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">auto</span> t1 = th1-&gt;fireAndForget([]</div>
<div class="line">        {</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 1, Step1&quot;</span> );</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#a31bcb7b51959dabec561a1ed4b3de4d7">::mel::tasking::Process::switchProcess</a>(<span class="keyword">true</span>);</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 1, Step2&quot;</span> );</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(2000);</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 1, Step3. Going to sleep..&quot;</span> );</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#a7d9fbde408b9e7b6a5dafa671a4048fd">::mel::tasking::Process::sleep</a>();</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 1, Awaken!!&quot;</span> );</div>
<div class="line"> </div>
<div class="line">        },0,Runnable::killFalse);</div>
<div class="line">    th1-&gt;fireAndForget([t1]</div>
<div class="line">        {</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 2, Step1&quot;</span> );</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(2500);</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 2, Step2&quot;</span> );</div>
<div class="line">            <a class="code" href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">::mel::tasking::Process::wait</a>(5000);</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Task 2, Going to wake up task1&quot;</span> );</div>
<div class="line">            t1-&gt;wakeUp();</div>
<div class="line">        },0,Runnable::killFalse);</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_html_a31bcb7b51959dabec561a1ed4b3de4d7"><div class="ttname"><a href="classmel_1_1tasking_1_1_process.html#a31bcb7b51959dabec561a1ed4b3de4d7">mel::tasking::Process::switchProcess</a></div><div class="ttdeci">static ESwitchResult switchProcess(bool continueInmediately) OPTIMIZE_FLAGS</div><div class="ttdoc">Evict current process and will continue executing from the same point the next time is scheduled.</div></div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_html_a7d9fbde408b9e7b6a5dafa671a4048fd"><div class="ttname"><a href="classmel_1_1tasking_1_1_process.html#a7d9fbde408b9e7b6a5dafa671a4048fd">mel::tasking::Process::sleep</a></div><div class="ttdeci">static ESwitchResult sleep() OPTIMIZE_FLAGS</div><div class="ttdoc">pause current process. To reactivate you must use wakeUp</div></div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_html_ae3350d1645cca8cb94f65b1b85dff032"><div class="ttname"><a href="classmel_1_1tasking_1_1_process.html#ae3350d1645cca8cb94f65b1b85dff032">mel::tasking::Process::wait</a></div><div class="ttdeci">static ESwitchResult wait(unsigned int msegs) OPTIMIZE_FLAGS</div></div>
</div><!-- fragment --><p>And the output will be: </p><div class="fragment"><div class="line">[2022-04-08 18:59:13.404] [info] Task 1, Step1</div>
<div class="line">[2022-04-08 18:59:15.705] [info] Task 2, Step1</div>
<div class="line">[2022-04-08 18:59:15.705] [info] Task 1, Step2</div>
<div class="line">[2022-04-08 18:59:15.705] [info] Task 1, Step3. Going to sleep..</div>
<div class="line">[2022-04-08 18:59:15.904] [info] Task 2, Step2</div>
<div class="line">[2022-04-08 18:59:20.904] [info] Task 2, Going to wake up task1</div>
<div class="line">[2022-04-08 18:59:20.904] [info] Task 1, Awaken!!</div>
</div><!-- fragment --><p>The "context-switch" functions return a value of type <a class="el" href="classmel_1_1tasking_1_1_process.html#ac83fa4ebb0bd022031febf1191a78fcb">Process::ESwitchResult</a> reporting the success or not of the call. This result code is very important in case of <em>process killing</em>: when a process is notified a <em>kill</em> (<a class="el" href="classmel_1_1tasking_1_1_process.html#a66583b3f1222e69ec9af4c142525fac8">mel::tasking::Process::kill</a>), if this process is in a "context-switched state", it won't be finished<a class="anchor" id="kill_switched_task"></a>, but it will return from this state with the code <a class="el" href="classmel_1_1tasking_1_1_process.html#ac83fa4ebb0bd022031febf1191a78fcba38ab43426e8046c0940ebbc713277994">mel::tasking::Process::ESwitchResult::ESWITCH_KILL</a>. The user should therefore check this code and, when killed, not continue executing. In the previous example, because the use of the fireAndForget and <a class="el" href="classmel_1_1tasking_1_1_runnable.html#a8321dac1a4a8f7415a5fdbcb5e540e62">killFalse</a>, it's not really neccesary to do those checks (although is convenient for consistency). In the next section we will go deeper in task management and this will become clearer.</p>
<p>It's important to note that <em>context switch functions</em> can be called in <em>anywhere in the call chain</em>, just the same way threading functions (<a class="el" href="classmel_1_1core_1_1_thread.html#ac4a0c4c1899348c015c92a265759c68d">sleep</a>, etc...) are used. So, this means that we could have this code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f1()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmel_1_1tasking_1_1_process.html#a31bcb7b51959dabec561a1ed4b3de4d7">::mel::tasking::Process::switchProcess</a>(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> f2()</div>
<div class="line">{</div>
<div class="line">    f1();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">auto</span> t1 = th1-&gt;fireAndForget([]</div>
<div class="line">    {</div>
<div class="line">        mel::text::info( <span class="stringliteral">&quot;Task 1, Step1&quot;</span> );</div>
<div class="line">        f1();</div>
<div class="line">    },0,Runnable::killFalse);</div>
</div><!-- fragment --><p>This point is very important and makes the main diference with usual coroutines in C++20 or in any other language and which make then not interchangeable. For example, lets see an example in javascript: </p><div class="fragment"></div><!-- fragment --> <h2><a class="anchor" id="terminating_tasks"></a>
Terminating tasks</h2>
<p>The way a task is killed was mentioned <a class="el" href="tasking_system.html#kill_situations">before</a>. Although users could need to directly call <a class="el" href="classmel_1_1tasking_1_1_process.html#a66583b3f1222e69ec9af4c142525fac8">kill</a> in some situations, usually this will be done automatically when using <a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html" title="Thread with Runnable behaviour.">mel::tasking::ThreadRunnable</a> : when an instance is destroyed, <b>it tries to kill all of its tasks and wait</b> (<a class="el" href="classmel_1_1tasking_1_1_thread_runnable.html#a753b36bb031cb4aac19a3badbafc5659">mel::tasking::ThreadRunnable::join</a>) for it. Let's see the following code: </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; killPolicy = Runnable::killFalse;</div>
<div class="line">    std::shared_ptr&lt;mel::tasking::Process&gt; task = th1-&gt;post([](uint64_t msecs,Process* p)</div>
<div class="line">        {            </div>
<div class="line">      mel::text::info( <span class="stringliteral">&quot;First Wait. {}&quot;</span> );</div>
<div class="line">      Process::wait(1000);</div>
<div class="line">      mel::text::info( <span class="stringliteral">&quot;Context switch:{}&quot;</span>);</div>
<div class="line">            Process::switchProcess(<span class="keyword">true</span>);</div>
<div class="line">            return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">        },killPolicy,period);</div>
<div class="line">    Thread::sleep(5000);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Here, a task is thrown, and, after 5 seconds, <em>th1</em> it's destroyed because the scope is left. In this destruction, <em>th1</em> send kill signal to all of its processes (only one in this case) and wait for its termination. But that process never ends for two reasons:</p><ul>
<li>it's always returning <a class="el" href="namespacemel_1_1tasking.html#a96d9377d27d919302df6839559a34a5da2f453cfe638e57e27bb0c9512436111e">CONTINUE</a></li>
<li><em>killPolicy</em> is set to <em>killFalse</em> , which means that this process won't be automatically killed when receiving kill signal</li>
</ul>
<p>So, in order the task to be killed, we could set the killPolicy to <em>true</em> as in the next code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleTasking4()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>MyString</div>
<div class="line">    {</div>
<div class="line">        MyString()</div>
<div class="line">        {</div>
<div class="line">            data = <span class="keyword">new</span> <span class="keywordtype">char</span>[10];</div>
<div class="line">            strcpy(data,<span class="stringliteral">&quot;Hello!&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        ~MyString()</div>
<div class="line">        {</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Destroying MyString&quot;</span>);</div>
<div class="line">            <span class="keyword">delete</span> []data;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">char</span>* data;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; killPolicy = Runnable::killTrue;</div>
<div class="line">    MyString str;</div>
<div class="line">    std::shared_ptr&lt;mel::tasking::Process&gt; task = th1-&gt;post([&amp;str](uint64_t msecs,Process* p)</div>
<div class="line">        {            </div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Before Wait. {}&quot;</span>,str.data );</div>
<div class="line">            Process::wait(10000);</div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;After Wait. {}&quot;</span>,str.data );            </div>
<div class="line">            return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">        },killPolicy,period);</div>
<div class="line">    Thread::sleep(5000);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, the code finishes ok, with output: </p><div class="fragment"><div class="line">[info] Before Wait. Hello!</div>
<div class="line">[info] Sleep done</div>
<div class="line">[info] Destroying MyString</div>
<div class="line">[info] After Wait. ¦¦¦¦¦¦¦¦¦¦¦¦¦¦</div>
</div><!-- fragment --><p> But that log is weird..the issue is that that task returns from the <em>wait</em> because the kill, but, as was explained <a class="el" href="tasking_system.html#kill_switched_task">here</a>, the task continue executing until the function finishes. So, this is what is happening:</p><ul>
<li>the task is <em>switched</em> in the <em>wait</em> line for <b>10 seconds</b></li>
<li>in the meanwhile, the calling thread sleeps or <b>5 seconds</b></li>
<li>once the thread sleep time has elapsed, the current scope ends and all inner objects are destroyed, **in the reverse order of their creation*. This means that <em>str</em> object is destroyed before <em>th1</em>.</li>
<li>In its destruction, th1 send kill signal to the task, which inmediately return from its wait. And, after that, the <em>str</em> object is accessed, so accesing invalid/corrupter memory. The solucion here is, therefore, check the return code in the <em>wait</em> function and not continue executing if returns from a kill signal: <div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleTasking4_ok()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>MyString</div>
<div class="line">    {</div>
<div class="line">        MyString()</div>
<div class="line">        {</div>
<div class="line">            data = <span class="keyword">new</span> <span class="keywordtype">char</span>[10];</div>
<div class="line">            strcpy(data,<span class="stringliteral">&quot;Hello!&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        ~MyString()</div>
<div class="line">        {</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Destroying MyString&quot;</span>);</div>
<div class="line">            <span class="keyword">delete</span> []data;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">char</span>* data;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; killPolicy = Runnable::killTrue;</div>
<div class="line">    MyString str;</div>
<div class="line">    std::shared_ptr&lt;mel::tasking::Process&gt; task = th1-&gt;post([&amp;str](uint64_t msecs,Process* p)</div>
<div class="line">        {            </div>
<div class="line">            mel::text::info( <span class="stringliteral">&quot;Before Wait. {}&quot;</span>,str.data );</div>
<div class="line">            <span class="keywordflow">if</span> ( Process::wait(10000) == Process::ESwitchResult::ESWITCH_OK)</div>
<div class="line">                mel::text::info( <span class="stringliteral">&quot;After Wait. {}&quot;</span>,str.data );            </div>
<div class="line">            return ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">        },killPolicy,period);</div>
<div class="line">    Thread::sleep(5000);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="custom_tasks"></a>
Custom task types</h2>
<p>Although posting tasks to runnables using callables (<a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">post</a>) is very flexible and enoguh in the vast majority of the cases, sometimes more control is needed. With the use of <a class="el" href="classmel_1_1tasking_1_1_runnable.html#a775fa406358dc7b798116ab68473c037">postTask</a> we can post directly an instance of a <a class="el" href="classmel_1_1tasking_1_1_process.html">Process</a> specialization. In this case, we will need to implemente some pure virtual member functions: </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>MyProcess : <span class="keyword">public</span> Process</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//optional, no pure</span></div>
<div class="line">        <span class="keywordtype">void</span> onInit(uint64_t msecs)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;MyProcess::oninit&quot;</span>);</div>
<div class="line">            count = 0;</div>
<div class="line">        };</div>
<div class="line">        <span class="comment">//mandatory, pure virtual</span></div>
<div class="line">        <span class="keywordtype">void</span> onUpdate(uint64_t msecs)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;MyProcess::onUpdate&quot;</span>);</div>
<div class="line">            ++count;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">//optional, no pure</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">bool</span> onKill()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> count == 10;</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">private</span>:</div>
<div class="line">            <span class="keywordtype">int</span> count;</div>
<div class="line"> </div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> period = 450; <span class="comment">//how often, msecs, the tasks is executed</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; killPolicy = Runnable::killFalse;</div>
<div class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;MyProcess&gt;();</div>
<div class="line">    task-&gt;setPeriod(1000); <span class="comment">//1 second period</span></div>
<div class="line">    th1-&gt;postTask(task);</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this example, a custom class with a custom behaviour, such that the process will be killed after 10 iterations (so, 10 seconds because period is set to 1 second).</p>
<p>Another way to customize the task type is by providing the <em>allocator</em> to use when posting a callable. There are two diferent ways of doing it:</p><ol type="1">
<li>Changing the default factory used when creating task through <a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">Runnable::post</a>: when a callable is posted to a Runnable, by default the underlying task is created using the <a class="el" href="structmel_1_1tasking_1_1_default_allocator.html">DefaultAllocator</a>, which uses de default factory set for this Runnable. Users can change this default factory by calling <a class="el" href="classmel_1_1tasking_1_1_runnable.html#a34e3ef27a129b113b00a0c40cee7090e">mel::tasking::Runnable::setDefaultFactory</a></li>
<li>Providing a custom <em>Allocator</em> as template parameter: the function <a class="el" href="classmel_1_1tasking_1_1_runnable.html#af513abe2b1af17b963b1262bfa271190">mel::tasking::Runnable::post</a> is templatized, receiving the <em>AllocatorType</em> as its first template parameter. The only requirement for this allocator is to have an <em>allocate</em> static function, as in <a class="el" href="structmel_1_1tasking_1_1_default_allocator.html#ae5319b499aef2b7db60ba0bffbe84e24">mel::tasking::DefaultAllocator::allocate</a></li>
</ol>
<p>Let's see an example for the method in 1. </p><div class="fragment"><div class="line"><span class="keyword">class </span>CustomProcessType : <span class="keyword">public</span> GenericProcess</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">    CustomProcessType()</div>
<div class="line">    {</div>
<div class="line">        ::mel::text::info(<span class="stringliteral">&quot;CustomProcessType constructor&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment">//custom factory to replace Runnable default factory</span></div>
<div class="line"><span class="keyword">class </span>CustomProcessFactory : <span class="keyword">public</span> <a class="code" href="classmel_1_1tasking_1_1_process_factory.html">mel::tasking::ProcessFactory</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        GenericProcess* <a class="code" href="classmel_1_1tasking_1_1_process_factory.html#a0c1076e213fb2a92c60dc75525570fac">onCreate</a>(Runnable* owner)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">new</span> CustomProcessType();</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">th1-&gt;setDefaultFactory( <span class="keyword">new</span> CustomProcessFactory );</div>
<div class="line">th1-&gt;fireAndForget( []</div>
<div class="line">{</div>
<div class="line">    mel::text::info(<span class="stringliteral">&quot;execute&quot;</span>);</div>
<div class="line">},0,Runnable::killTrue);</div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_factory_html"><div class="ttname"><a href="classmel_1_1tasking_1_1_process_factory.html">mel::tasking::ProcessFactory</a></div><div class="ttdoc">Base factory class for tasks.</div><div class="ttdef"><b>Definition:</b> Runnable.h:63</div></div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_factory_html_a0c1076e213fb2a92c60dc75525570fac"><div class="ttname"><a href="classmel_1_1tasking_1_1_process_factory.html#a0c1076e213fb2a92c60dc75525570fac">mel::tasking::ProcessFactory::onCreate</a></div><div class="ttdeci">virtual GenericProcess * onCreate(Runnable *owner) const</div><div class="ttdoc">Reimplement in children to change default behaviour.</div></div>
</div><!-- fragment --><p> One the factory is set, all the tasks posted to that Runnable will be created through it.</p>
<p>And now, an example for the method in 2. </p><div class="fragment"><div class="line"><span class="comment">//custom factory </span></div>
<div class="line"><span class="keyword">class </span>CustomProcessFactory</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        GenericProcess* <a class="code" href="classmel_1_1tasking_1_1_process_factory.html#a273fd2df5c4ac9c76f86839b4ce9dc1c">create</a>(Runnable* owner)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">new</span> GenericProcess();</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"><span class="comment">//setting factory in post</span></div>
<div class="line"><span class="keyword">struct </span>MyAllocator</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> GenericProcess* allocate(Runnable* _this)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> factory.create(_this);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> CustomProcessFactory factory;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> _sampleTasking7()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//custom allocator which will use out CustomProcessFactory, not inheriting from ProcessFactory, so best performance</span></div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    th1-&gt;fireAndForget&lt;MyAllocator&gt;( []</div>
<div class="line">    {</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;execute&quot;</span>);</div>
<div class="line">    },0,Runnable::killFalse);</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1tasking_1_1_process_factory_html_a273fd2df5c4ac9c76f86839b4ce9dc1c"><div class="ttname"><a href="classmel_1_1tasking_1_1_process_factory.html#a273fd2df5c4ac9c76f86839b4ce9dc1c">mel::tasking::ProcessFactory::create</a></div><div class="ttdeci">GenericProcess * create(Runnable *owner) const</div><div class="ttdoc">Create new process for given Runnable.</div><div class="ttdef"><b>Definition:</b> Runnable.h:66</div></div>
</div><!-- fragment --><p> With this last method, given allocator is only used for this concrete case, any other post on that Runnable will use the <a class="el" href="structmel_1_1tasking_1_1_default_allocator.html">DefaultAllocator</a> (or its own if given as in this example). As can be seen, the given factory for this case doesn't need to inherit from <a class="el" href="classmel_1_1tasking_1_1_process_factory.html">ProcessFactory</a>, so saving the cost of a virtual function call, which could be very important if used in an environment where performance is critical. </p>
<h2><a class="anchor" id="runnable_specialization"></a>
Runnable specialization</h2>
<p>The base <a class="el" href="classmel_1_1tasking_1_1_runnable.html">Runnable</a> task doesn''t do any work. You will need to specialize it. Let's see the most basic example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleCustomRunnable()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>MyRunnable : <span class="keyword">public</span> Runnable</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">//create a Runnable with default options</span></div>
<div class="line">            MyRunnable():Runnable( Runnable::RunnableCreationOptions())</div>
<div class="line">            {</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line">            <span class="comment">//needed because Runnable::processTasks is protected</span></div>
<div class="line">            <span class="keywordtype">void</span> processTasks()</div>
<div class="line">            {</div>
<div class="line">                Runnable::processTasks();</div>
<div class="line">            }</div>
<div class="line">    };</div>
<div class="line">    MyRunnable r;</div>
<div class="line">    r.post([](RUNNABLE_TASK_PARAMS)</div>
<div class="line">    {</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Task 1&quot;</span>);</div>
<div class="line">        Process::wait(1000);</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Task 1 - end&quot;</span>);</div>
<div class="line">        return  ::mel::tasking::EGenericProcessResult::CONTINUE;</div>
<div class="line">    });</div>
<div class="line">    r.fireAndForget([]</div>
<div class="line">    {</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Task 2&quot;</span>);</div>
<div class="line">        Process::wait(1000);</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Task 2 - end&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">    {    </div>
<div class="line">        r.processTasks();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The only thing the Runnable specialization (MyRunnable) has to do, is to call <code>Runnable::processTasks</code> which is a protected function not exposed publicy to avoid calling it by the users.</p>
<h2><a class="anchor" id="sync_macros"></a>
Synchronization macros</h2>
<p>In many situations, some functions or member functions need to be called in a concrete Runnable. For example, is typical in a UI system or graphics engine to be obliged to execute their functions in a concrete thread. In that cases, the user should know this limitation and take care of that when calling that functions.</p>
<p>MEL provide the mechanisms to force these functions execution in their mandatory Runnable. For this purpose there are a couple of macros in <a class="el" href="synchronization__macros_8h.html">synchronization_macros.h</a>. As always, let's see an example: </p><div class="fragment"><div class="line">std::shared_ptr&lt;Runnable&gt; sRunnable;  <span class="comment">// created somewhere...</span></div>
<div class="line"><a class="code" href="synchronization__macros_8h.html#acf032ec40ae26021883725e4b66a6423">SYNCHRONIZED_STATIC</a>( f1,<span class="keywordtype">int</span>,(<span class="keywordtype">int</span>),,sRunnable ) ;    </div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> f1_sync(<span class="keywordtype">int</span> v)  </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;ERROR in f1!!!!&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> v + 5;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="synchronization__macros_8h.html#af1d9511834b9e945980e6c1f223fe07b">SYNCHRONIZED_METHOD</a>( f2,<span class="keywordtype">string</span>,(<span class="keywordtype">int</span>,<span class="keywordtype">float</span>),noexcept,sRunnable) ;   </div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">string</span> MyClass::f2_sync(<span class="keywordtype">int</span> v1,<span class="keywordtype">float</span> v2) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f2_sync &quot;</span>+std::to_string(v1)+<span class="stringliteral">&quot; &quot;</span>+std::to_string(v2);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> _sampleSyncMacros()</div>
<div class="line">{</div>
<div class="line">    sRunnable = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    {</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Calling static function f1 syncronized with a Runnable&quot;</span>);</div>
<div class="line">        <span class="keyword">auto</span> r = f1(6);</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1core.html#a6d42aa88f8243f26b4acd1d336288091">mel::core::waitForFutureThread</a>(r);</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Result = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">        {</div>
<div class="line">            mel::text::error(<span class="stringliteral">&quot;Exception!!. {}&quot;</span>,e.what());</div>
<div class="line">        }</div>
<div class="line">       </div>
<div class="line">    }</div>
<div class="line">    {</div>
<div class="line">        MyClass obj;</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Calling static function f2 syncronized with a Runnable&quot;</span>);</div>
<div class="line">        <span class="keyword">auto</span> r2 = obj.f2(6,9.1f);</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> res = <a class="code" href="namespacemel_1_1core.html#a6d42aa88f8243f26b4acd1d336288091">mel::core::waitForFutureThread</a>(r2);</div>
<div class="line">            mel::text::info(<span class="stringliteral">&quot;Result = {}&quot;</span>,res.value());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">        {</div>
<div class="line">            mel::text::error(<span class="stringliteral">&quot;Exception!!. {}&quot;</span>,e.what());</div>
<div class="line">        }       </div>
<div class="line">    }  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Output:</div>
<div class="line"> </div>
<div class="line">[info] Calling <span class="keyword">static</span> <span class="keyword">function</span> f1 syncronized with a Runnable</div>
<div class="line">[error] Exception!!. ERROR in f1!!!!</div>
<div class="line">[info] Calling <span class="keyword">static</span> <span class="keyword">function</span> f2 syncronized with a Runnable</div>
<div class="line">[info] Result = f2_sync 6 9.100000</div>
<div class="ttc" id="anamespacemel_1_1core_html_a6d42aa88f8243f26b4acd1d336288091"><div class="ttname"><a href="namespacemel_1_1core.html#a6d42aa88f8243f26b4acd1d336288091">mel::core::waitForFutureThread</a></div><div class="ttdeci">::mel::core::WaitResult&lt; T &gt; waitForFutureThread(const mel::core::Future&lt; T &gt; &amp;f, unsigned int msecs=::mel::core::Event::EVENT_WAIT_INFINITE)</div><div class="ttdoc">Wait for a Future from a Thread</div><div class="ttdef"><b>Definition:</b> Thread.h:221</div></div>
<div class="ttc" id="asynchronization__macros_8h_html_acf032ec40ae26021883725e4b66a6423"><div class="ttname"><a href="synchronization__macros_8h.html#acf032ec40ae26021883725e4b66a6423">SYNCHRONIZED_STATIC</a></div><div class="ttdeci">#define SYNCHRONIZED_STATIC(function_name, TRet, args, qualifiers, runnable)</div><div class="ttdoc">Define a static function synchronized with a given runnable.</div><div class="ttdef"><b>Definition:</b> synchronization_macros.h:76</div></div>
<div class="ttc" id="asynchronization__macros_8h_html_af1d9511834b9e945980e6c1f223fe07b"><div class="ttname"><a href="synchronization__macros_8h.html#af1d9511834b9e945980e6c1f223fe07b">SYNCHRONIZED_METHOD</a></div><div class="ttdeci">#define SYNCHRONIZED_METHOD(function_name, TRet, args, qualifiers, runnable)</div><div class="ttdoc">Define a method synchronized with a given runnable.</div><div class="ttdef"><b>Definition:</b> synchronization_macros.h:90</div></div>
</div><!-- fragment --><p> In this example we define two functions synchronized with a Runnable called <em>sRunnable</em> (where, when and how is created depends on the concrete application, and it's not shown to not obfuscate the code). This means that, executing those functions will really execute them in the given Runnable. This implies that result should be a <a class="el" href="classmel_1_1core_1_1_future.html">Future</a> because it will be resolved when <em>sRunnable</em> is able to do it, so user can wait for this value in any of the <a class="el" href="tasking_constructs.html#futures_section">wait methods</a></p>
<h2><a class="anchor" id="limitations"></a>
Known limitations</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Careful with local variables and microthreads</h3>
<p>The <em>stackless</em> nature of the microthreads (in the sense that, by default, the don't use its own stack) implies a confusing limitation, that can be overcame very easily. This techniques have been in use since earlies 2000s and this limitation is not really important, but is neccesary to explain it. Let's see an example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> _sampleLimitation()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>);</div>
<div class="line">    th1-&gt;fireAndForget([th = th1.get()]</div>
<div class="line">    {</div>
<div class="line">        int a = 5;</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;Set &#39;a&#39; = {}&quot;</span>,a);</div>
<div class="line">        th-&gt;fireAndForget([&amp;a]</div>
<div class="line">            {</div>
<div class="line">                mel::text::info(<span class="stringliteral">&quot;&#39;a&#39; = {}&quot;</span>,a);</div>
<div class="line">                a = 10;</div>
<div class="line">            }</div>
<div class="line">        ,0,Runnable::killFalse);</div>
<div class="line">        Process::wait(5000);</div>
<div class="line">        mel::text::info(<span class="stringliteral">&quot;At end &#39;a&#39; = {}&quot;</span>,a);</div>
<div class="line">    },0,Runnable::killFalse);     </div>
<div class="line">}</div>
</div><!-- fragment --><p> This code does the following: a task launched in <em>th1</em> launch another task to the same ThreadRunnable (but any other ThreadRunnable would be valid) passing it <em>a reference to a local variable</em>. After that, the first task waits for 5 seconds, so the second task is executed and change the reference variable to a new value. The expected result should be: </p><div class="fragment"><div class="line">Set <span class="charliteral">&#39;a&#39;</span> = 5</div>
<div class="line"><span class="charliteral">&#39;a&#39;</span> = 327675</div>
<div class="line">At end <span class="charliteral">&#39;a&#39;</span> = 10</div>
</div><!-- fragment --><p> But the output is the following: </p><div class="fragment"><div class="line">Set <span class="charliteral">&#39;a&#39;</span> = 5</div>
<div class="line"><span class="charliteral">&#39;a&#39;</span> = 32767</div>
<div class="line">At end <span class="charliteral">&#39;a&#39;</span> = 5</div>
</div><!-- fragment --><p> The reason is that, when first task does the <em>wait</em>, the stack has been unwund, so the reference to variable <code>a</code> is no more valid. So,careful have to be taken when passing local variables to a function and a context switch is done. </p>
<h3><a class="anchor" id="autotoc_md4"></a>
Careful with executing tasks in a Runnable</h3>
<p>If we change the code in #runnable_specialization and do the following: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> f1 = [&amp;r]</div>
<div class="line">{</div>
<div class="line">    r.processTasks();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> f2 = [&amp;r]</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> a[100];</div>
<div class="line">    r.processTasks();</div>
<div class="line">};</div>
<div class="line"><span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">{           </div>
<div class="line">    f1();</div>
<div class="line">    f2();</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the previous code, two labmdas are created, such that one of them declares a loval variable. But the code, the only thing it does, is execute <code>r.processTasks()</code> two times. But the second time, the <em>stack at the point of execution is different</em>. If you execute that code, it throws an assert (in debug mode, in release it will crash). The reason is that task execution *must always be called with the stack in same place, so, this means executing <code>processTasks</code> always from same place. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
