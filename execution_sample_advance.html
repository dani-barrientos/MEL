<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEL: Advanced example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEL
   </div>
   <div id="projectbrief">Microthread &amp; Execution library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('execution_sample_advance.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Advanced example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Although the code shown in this section is not really complicated, it's a more real one and allow us to check performance aspects. The goal of this example is simply to calculate the mean of a very big vector. We will have a template function to abstract from execution agent. This is the code: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ExecutorType&gt; <span class="keywordtype">void</span> _testMeanVector(::<a class="code" href="classmel_1_1execution_1_1_ex_future.html">mel::execution::ExFuture</a>&lt;ExecutorType,vector&lt;double&gt;&gt; fut,tests::BaseTest* test)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> vector&lt;double&gt; VectorType;</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        Timer timer;</div>
<div class="line">        uint64_t t0 = timer.getMilliseconds();</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> res5 = <a class="code" href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a>( </div>
<div class="line">        fut</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#a34720de187eb00f270e0867b9b663ce6">mel::execution::parallel_convert</a>(  <span class="comment">//calculate mean in 4 parts @todo ¿cómo podrái devolver este resultado a siguiente funcion?</span></div>
<div class="line">            [](<span class="keyword">const</span> VectorType&amp; v) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> mean = 0.f;</div>
<div class="line">                <span class="keywordtype">size_t</span> tam = v.size()/4;</div>
<div class="line">                <span class="keywordtype">size_t</span> endIdx = tam;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; endIdx;++i)</div>
<div class="line">                    mean += v[i];</div>
<div class="line">                mean /= v.size();</div>
<div class="line">                <span class="keywordflow">return</span> mean;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> VectorType&amp; v) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> mean = 0.f;</div>
<div class="line">                <span class="keywordtype">size_t</span> tam = v.size()/4;</div>
<div class="line">                <span class="keywordtype">size_t</span> startIdx = tam;</div>
<div class="line">                <span class="keywordtype">size_t</span> endIdx = tam*2;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = startIdx; i &lt; endIdx;++i)</div>
<div class="line">                    mean += v[i];</div>
<div class="line">                mean /= v.size();</div>
<div class="line">                <span class="keywordflow">return</span> mean;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> VectorType&amp; v) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> mean = 0.f;</div>
<div class="line">                <span class="keywordtype">size_t</span> tam = v.size()/4;</div>
<div class="line">                <span class="keywordtype">size_t</span> startIdx = tam*2;</div>
<div class="line">                <span class="keywordtype">size_t</span> endIdx = tam*3;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = startIdx; i &lt; endIdx;++i)</div>
<div class="line">                    mean += v[i];</div>
<div class="line">                mean /= v.size();</div>
<div class="line">                <span class="keywordflow">return</span> mean;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> VectorType&amp; v) noexcept</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> mean = 0.f;</div>
<div class="line">                <span class="keywordtype">size_t</span> tam = v.size()/4;</div>
<div class="line">                <span class="keywordtype">size_t</span> startIdx = tam*3;</div>
<div class="line">                <span class="keywordtype">size_t</span> endIdx = v.size();</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = startIdx; i &lt; endIdx;++i)</div>
<div class="line">                    mean += v[i];</div>
<div class="line">                mean /= v.size();</div>
<div class="line">                <span class="keywordflow">return</span> mean;</div>
<div class="line">            }</div>
<div class="line">        ) | <a class="code" href="namespacemel_1_1execution.html#a40a64bdbc54577344ba83fba6dad1f35">mel::execution::next</a>( [](<span class="keyword">const</span> std::tuple&lt;double,double,double,double&gt;&amp; means)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> (std::get&lt;0&gt;(means)+std::get&lt;1&gt;(means)+std::get&lt;2&gt;(means)+std::get&lt;3&gt;(means));</div>
<div class="line">        }));</div>
<div class="line">        uint64_t t1 = timer.getMilliseconds();</div>
<div class="line">        text::info(<span class="stringliteral">&quot;Mean = {}. Time spent = {} seconds&quot;</span>,res5.value(),(<span class="keywordtype">float</span>)((t1-t0)/1000.f));</div>
<div class="line">    }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">    {</div>
<div class="line">        text::info(<span class="stringliteral">&quot;Error = {}&quot;</span>,e.what());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassmel_1_1execution_1_1_ex_future_html"><div class="ttname"><a href="classmel_1_1execution_1_1_ex_future.html">mel::execution::ExFuture</a></div><div class="ttdoc">Extension of mel::core::Future to apply to executors.</div><div class="ttdef"><b>Definition:</b> ExFuture.h:20</div></div>
<div class="ttc" id="anamespacemel_1_1core_html_a104e002cdbc28f6e37b771760742e3b6"><div class="ttname"><a href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a></div><div class="ttdeci">::mel::core::WaitResult&lt; T &gt; waitForFutureThread(const mel::core::Future&lt; T &gt; &amp;f, unsigned int msecs=::mel::core::Event::EVENT_WAIT_INFINITE) noexcept(std::is_same&lt; ErrorType,::mel::core::WaitErrorNoException &gt;::value)</div><div class="ttdoc">Wait for a Future from a Thread</div><div class="ttdef"><b>Definition:</b> Thread.h:226</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_a34720de187eb00f270e0867b9b663ce6"><div class="ttname"><a href="namespacemel_1_1execution.html#a34720de187eb00f270e0867b9b663ce6">mel::execution::parallel_convert</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, typename ::mel::execution::_private::GetReturn&lt; TArg, FTypes... &gt;::type &gt; parallel_convert(ExFuture&lt; ExecutorAgent, TArg &gt; source, FTypes &amp;&amp;... functions)</div><div class="ttdoc">Same as parallel but returning a tuple with the values for each functor.</div><div class="ttdef"><b>Definition:</b> Executor.h:487</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_a40a64bdbc54577344ba83fba6dad1f35"><div class="ttname"><a href="namespacemel_1_1execution.html#a40a64bdbc54577344ba83fba6dad1f35">mel::execution::next</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, std::invoke_result_t&lt; F, TArg &gt; &gt; next(ExFuture&lt; ExecutorAgent, TArg &gt; source, F &amp;&amp;f)</div><div class="ttdoc">Attach a functor to execute when input fut is complete Given functor will be executed inf the input E...</div><div class="ttdef"><b>Definition:</b> Executor.h:128</div></div>
</div><!-- fragment --><p> And from the <em>main</em> function: </p><div class="fragment"><div class="line">Runnable::RunnableCreationOptions opts;</div>
<div class="line">opts.schedulerOpts = ProcessScheduler::LockFreeOptions{};</div>
<div class="line"><span class="keyword">auto</span> th1 = ThreadRunnable::create(<span class="keyword">true</span>,opts);</div>
<div class="line">execution::Executor&lt;Runnable&gt; exr(th1);</div>
<div class="line"><span class="keyword">typedef</span> vector&lt;double&gt; VectorType;</div>
<div class="line"><span class="keyword">auto</span> initFut = execution::launch(exr,[]()</div>
<div class="line">{               </div>
<div class="line">    <span class="comment">//int vecSize = std::rand()%1000&#39;000; //generate random big vector</span></div>
<div class="line">    constexpr <span class="keywordtype">int</span> vecSize = 100&#39;000&#39;000;</div>
<div class="line">    VectorType v(vecSize);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; vecSize;++i)</div>
<div class="line">        v[i] = (std::rand()%20)/3.0; <span class="comment">//to create a double</span></div>
<div class="line">    <span class="keywordflow">return</span> v;</div>
<div class="line">});</div>
<div class="line">core::waitForFutureThread(initFut); <span class="comment">//wait for completion of vector creation to not interfere in time measurement</span></div>
<div class="line"><span class="keyword">auto</span> initRes = core::waitForFutureThread&lt;mel::core::WaitErrorNoException&gt;( initFut );</div>
<div class="line">Timer timer;</div>
<div class="line">uint64_t t0 = timer.getMilliseconds();</div>
<div class="line"> </div>
<div class="line"><span class="comment">//plain version</span></div>
<div class="line">text::info(<span class="stringliteral">&quot;vector mean: plain way&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> mean = 0.0;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; v = initRes.value();</div>
<div class="line">    <span class="keywordtype">size_t</span> endIdx = v.size();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; endIdx;++i)</div>
<div class="line">        mean+=v[i];</div>
<div class="line">    mean/=v.size(); </div>
<div class="line">}   </div>
<div class="line">uint64_t t1 = timer.getMilliseconds();</div>
<div class="line">mel::text::info(<span class="stringliteral">&quot;Mean = {}. Time spent = {}&quot;</span>,mean,(<span class="keywordtype">float</span>)((t1-t0)/1000.f)); </div>
<div class="line">{       </div>
<div class="line">    parallelism::ThreadPool::ThreadPoolOpts opts;</div>
<div class="line">    opts.threadOpts.schedulerOpts = ProcessScheduler::LockFreeOptions{};</div>
<div class="line">    <span class="keyword">auto</span> myPool = make_shared&lt;parallelism::ThreadPool&gt;(opts);</div>
<div class="line">    parallelism::ThreadPool::ExecutionOpts exopts;</div>
<div class="line">    execution::Executor&lt;parallelism::ThreadPool&gt; extp(myPool);</div>
<div class="line">    extp.setOpts({<span class="keyword">true</span>,<span class="keyword">true</span>});</div>
<div class="line">    text::info(<span class="stringliteral">&quot;vector mean: ThreadPoolExecutor&quot;</span>);</div>
<div class="line">    _testMeanVector( execution::transfer(initFut,extp),<span class="stringliteral">&quot;vector mean: ThreadPoolExecutor&quot;</span>,test);</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">    exr.setOpts({<span class="keyword">true</span>,<span class="keyword">false</span>});</div>
<div class="line">    text::info(<span class="stringliteral">&quot;vector mean: RunnableExecutor&quot;</span>);        </div>
<div class="line">    _testMeanVector(execution::transfer(initFut,exr),<span class="stringliteral">&quot;vector mean: RunnableExecutor&quot;</span>,test); <span class="comment">//the transfer is not neccesary because initFut is launched in exr, but jsut in case it changes</span></div>
<div class="line">}</div>
<div class="line">{       </div>
<div class="line">    execution::InlineExecutor ex;</div>
<div class="line">    text::info(<span class="stringliteral">&quot;vector mean: InlineExecutor&quot;</span>);      </div>
<div class="line">    _testMeanVector( execution::transfer(initFut,ex),<span class="stringliteral">&quot;vector mean: InlineExecutor&quot;</span>,test);</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this code, a very big vector is created, and the mean of its values is calculated by:</p><ul>
<li>spliting the vector in 4 parts and calculating the mean on each. this is done in using <a class="el" href="namespacemel_1_1execution.html#a34720de187eb00f270e0867b9b663ce6">parallel_convert</a> with 4 <em>parallel</em> tasks, each of which returns its own mean, so the full result of this job is a tuple.</li>
<li>passing the previous tuple with <a class="el" href="namespacemel_1_1execution.html#a40a64bdbc54577344ba83fba6dad1f35">next</a> to a callable which sums the four measurements.</li>
</ul>
<p>Also, at first, a plain calculation is done to compare de results. In the concrete machine uses at this moment, the output is: </p><pre class="fragment">vector mean: plain way
    Mean = 3.1669570700186305. Time spent = 0.092
vector mean: ThreadPoolExecutor
    Mean = 3.166957070004096. Time spent = 0.044 seconds
vector mean: RunnableExecutor
    Mean = 3.166957070004096. Time spent = 0.093 seconds
vector mean: InlineExecutor
    Mean = 3.166957070004096. Time spent = 0.091 seconds
</pre><p> The results show two very good news:</p><ul>
<li>using a <a class="el" href="namespacemel_1_1execution.html#a5e0ddd0955796bd634b11035be2161d7">ThreadPoolExecutor</a> is more than double faster than a simple <a class="el" href="namespacemel_1_1execution.html#a0c008697e5e12a69ade00e0fd0ae3254">RunnableExecutor</a>. By default a ThreadPool uses all available cores. In this used machine, the number of cores is 8, so each task in <em>parallel_convert</em> is fully independent. Although apparently this should mean that the code should be 4 times faster, other things can affect performance, mainly cache issues.</li>
<li>the direct way and the <a class="el" href="namespacemel_1_1execution.html#adee1d4b15ec1985a4bde524b726babaa">InlineExecutor</a> takes almost the same time that the <em>RunnableExecutor</em> way, meaning that the internals of the execution and microthread system has very,very low penalty.</li>
</ul>
<p>In order to do improve the previous code, it had been better to take advantage of concrete parallelism possibilities of the system. Instead of dividing the input vector in 4 different parts, It would be better to divide in as much parts as the system can. The code could be: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        Timer timer;</div>
<div class="line">        uint64_t t0 = timer.getMilliseconds();</div>
<div class="line">        <span class="keywordtype">int</span> numParts = ExecutorTraits&lt;Executor&lt;ExecutorType&gt;&gt;::has_parallelism?<a class="code" href="namespacemel_1_1core.html#a566d83eac83e728480e727dbfe24753d">mel::core::getNumProcessors</a>():1;</div>
<div class="line">        vector&lt;double&gt; means(numParts);</div>
<div class="line">        <span class="keyword">auto</span> res5 = <a class="code" href="namespacemel_1_1core.html#a104e002cdbc28f6e37b771760742e3b6">mel::core::waitForFutureThread</a>(</div>
<div class="line">        fut</div>
<div class="line">        | <a class="code" href="namespacemel_1_1execution.html#acbcaf139dc87026232b3816d7ecb256e">mel::execution::loop</a>(</div>
<div class="line">                        0,(<span class="keywordtype">int</span>)numParts,</div>
<div class="line">                        [&amp;means,numParts](<span class="keywordtype">int</span> idx,VectorType&amp; v) noexcept</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keywordtype">double</span> mean = 0.f;</div>
<div class="line">                            <span class="keywordtype">size_t</span> tam = v.size()/numParts;  <span class="comment">//size of each sub-vector</span></div>
<div class="line">                            <span class="keywordtype">size_t</span> startIdx = idx*tam;</div>
<div class="line">                            <span class="keywordtype">size_t</span> endIdx;</div>
<div class="line">                            <span class="keywordflow">if</span> ( idx == numParts-1)</div>
<div class="line">                                endIdx = v.size();</div>
<div class="line">                            <span class="keywordflow">else</span></div>
<div class="line">                                endIdx = startIdx+tam;</div>
<div class="line">                            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = startIdx; i &lt; endIdx;++i)</div>
<div class="line">                                mean += v[i];</div>
<div class="line">                            mean /= v.size();</div>
<div class="line">                            means[idx] = mean;</div>
<div class="line">                        },1</div>
<div class="line">                    )</div>
<div class="line">         | <a class="code" href="namespacemel_1_1execution.html#a40a64bdbc54577344ba83fba6dad1f35">mel::execution::next</a>( [&amp;means](VectorType&amp;)</div>
<div class="line">         {</div>
<div class="line">            <span class="keywordtype">double</span> mean = 0.0;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; means.size();++i)</div>
<div class="line">                mean+=means[i];</div>
<div class="line">            <span class="keywordflow">return</span> mean; </div>
<div class="line">         })     </div>
<div class="line">        );</div>
<div class="line">        uint64_t t1 = timer.getMilliseconds();</div>
<div class="line">        text::info(<span class="stringliteral">&quot;Using loop. Mean = {}. Time spent = {} seconds&quot;</span>,res5.value(),(<span class="keywordtype">float</span>)((t1-t0)/1000.f));</div>
<div class="line">    }<span class="keywordflow">catch</span>(std::exception&amp; e)</div>
<div class="line">    {</div>
<div class="line">        text::info(<span class="stringliteral">&quot;Error = {}&quot;</span>,e.what());</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacemel_1_1core_html_a566d83eac83e728480e727dbfe24753d"><div class="ttname"><a href="namespacemel_1_1core.html#a566d83eac83e728480e727dbfe24753d">mel::core::getNumProcessors</a></div><div class="ttdeci">MEL_API unsigned int getNumProcessors()</div><div class="ttdoc">Get the number of logical processors.</div></div>
<div class="ttc" id="anamespacemel_1_1execution_html_acbcaf139dc87026232b3816d7ecb256e"><div class="ttname"><a href="namespacemel_1_1execution.html#acbcaf139dc87026232b3816d7ecb256e">mel::execution::loop</a></div><div class="ttdeci">ExFuture&lt; ExecutorAgent, TArg &gt; loop(ExFuture&lt; ExecutorAgent, TArg &gt; source, I &amp;&amp;begin, I &amp;&amp;end, F &amp;&amp;functor, int increment=1)</div><div class="ttdoc">parallel (possibly, depending on executor capabilities) loop</div><div class="ttdef"><b>Definition:</b> Executor.h:221</div></div>
</div><!-- fragment --><p> In this new version, <a class="el" href="namespacemel_1_1execution.html#acbcaf139dc87026232b3816d7ecb256e">loop</a> is used, doing as much iterations as available cores. Also, the parallelism capabilities of the used executor is checked with <a class="el" href="structmel_1_1execution_1_1_executor_traits.html">ExecutorTraits</a>, such that, with no real parallelism , dividing processing in chunks doesn't0 make any advantage (also the loss is minimal as was seen in the previous example). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
